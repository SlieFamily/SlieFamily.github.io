<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>C++|从C到C++快速入门 | SLie's Blog|琴弦之轮</title><meta name="author" content="Slie"><meta name="copyright" content="Slie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简述C++  C语言是面向过程的一门编程语言，“将要解决的问题分解成一个个小问题，依次解决” C+ +是对C语言的扩展和增强 : 面向对象、通用算法(泛型编程)   待更  标准库 C++ 中包含了C标准库的移植版本，C标准库的头文件xxx.h 基本上 变成了cxxx。 如stdio.h在C+ +中"><link rel="shortcut icon" href="/img/%E7%A3%81%E5%B8%A6.png"><link rel="canonical" href="https://qslie.top/posts/faf498b7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:{limitDay:90,position:"top",messagePrev:"本文章距离上次修改已经过了",messageNext:"天，相关内容可能不再适用，请留意."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-center"},source:{justifiedGallery:{js:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js",css:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C++|从C到C++快速入门",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-03-11 22:44:06"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/fixed_comment.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/twikoo_beautify.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/04/09/Likong.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>声影</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/films/"><i class="fa-fw fas fa-video"></i> <span>映像</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>图书</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://z3.ax1x.com/2021/04/17/c5P76I.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="SLie's Blog|琴弦之轮"><span class="site-name">SLie's Blog|琴弦之轮</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>声影</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/films/"><i class="fa-fw fas fa-video"></i> <span>映像</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>图书</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++|从C到C++快速入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-19T07:06:30.000Z" title="发表于 2020-06-19 15:06:30">2020-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-11T14:44:06.489Z" title="更新于 2024-03-11 22:44:06">2024-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/">计算机科学与技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/C%E7%B3%BB%E5%88%97/">C系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="C++|从C到C++快速入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image:url(https://z3.ax1x.com/2021/04/17/c5P76I.jpg)"></div><article class="post-content" id="article-container"><h2 id="简述C">简述C++</h2><ul><li>C语言是<strong>面向过程</strong>的一门编程语言，“将要解决的问题分解成一个个小问题，依次解决”</li><li>C+ +是对C语言的扩展和增强 : <strong>面向对象</strong>、通用算法(<strong>泛型</strong>编程)</li></ul><blockquote><p>待更</p></blockquote><h2 id="标准库">标准库</h2><p><strong>C++</strong> 中包含了C标准库的<strong>移植</strong>版本，C标准库的头文件<code>xxx.h</code> <strong>基本上</strong> 变成了<code>cxxx</code>。</p><p>如<code>stdio.h</code>在C+ +中对应的是<code>cstdio</code>、<code>math.h</code>变成 了<code>cmath</code>、<code>string.h</code>变成 了<code>cstring</code>等</p><p>当然，并不是所有头文件都是如此，如<code>malloc.h</code>仍然不变。</p><br>## 条件编译<p>在C语言中，我们学过 <strong>条件编译</strong>，使用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 条件表达式</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>功能为：如果<code>#if</code>后的条件表达式为真，则<code>程序段 1</code> 被选中，否则<code>程序段 2</code> 被选中。</p><p><strong>注意</strong>，必须使用 <code>#endif</code> 结束该条件编译指令。</p><p>当然不止有以上的使用，还有将<strong>是否进行了某宏定义</strong>作为触发条件的条件编译。</p><table><thead><tr><th>条件编译指令</th><th>说明</th></tr></thead><tbody><tr><td><code>#if</code></td><td>如果条件为真，则执行相应操作</td></tr><tr><td><code>#elif</code></td><td>如果前面条件为假，而该条件为真，则执行相应操作</td></tr><tr><td><code>#else</code></td><td>如果前面条件均为假，则执行相应操作</td></tr><tr><td><code>#endif</code></td><td>结束相应的条件编译指令</td></tr><tr><td><code>#ifdef</code></td><td>如果该宏已定义，则执行相应操作</td></tr><tr><td><code>#ifndef</code></td><td>如果该宏没有定义，则执行相应操作</td></tr></tbody></table><p>条件编译在编写头文件的时候可以防止重复引用造成的程序错误问题，现已成为编写头文件时墨守成规的格式了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADERFILENAME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADERFILENAME_H</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	   头文件内容</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注:HEADERFILENAME即是头文件的文件名</span></span><br><span class="line"><span class="comment">		(宏定义时注意用大写)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>## 名字空间<blockquote><p>名字空间 可以类比于存放变量名的空间。某个变量在当前名字空间下所代表的含义可以与其他名字空间的变量不同。</p><p>例如不同班级都可能有同名的学生，如“张伟”，<strong>为防止对象名冲突，因此需要使用空间限定</strong>。</p><ul><li>计科1701:: 张伟</li><li>机械1 803:: 张伟</li></ul></blockquote><br><p><strong>名字空间</strong>除了系统定义的名字空间之外，还可以自己定义，定义名字空间用关键字<code>namespace</code>，使用名字空间时用符号<code>::</code>对其指定。</p><ol><li><strong>不指定</strong>名字空间的变量或函数都是<strong>当前名字空间</strong>下的变量或函数。</li><li>不定义名字空间的情况下，<strong>都</strong>属于全局名字空间。</li><li>同一个名字空间可以<strong>定义多次</strong></li></ol><p><strong>使用：</strong></p><ul><li><p><code>名字空间::名字</code>：每次需要使用该名字空间下的对象时，在<code>main()</code>内部通过此代码代替对象明本身。</p></li><li><p><code>using 名字空间::名字</code>：在开头进行声明，代表此后的对象名字为<code>名字</code>的对象都代表的是<code>名字空间</code>里的那个变量</p></li><li><p><code>using namespace std</code>：在开头声明引入<code>名字空间</code>中所有的名字，此后就不再重复对某个变量进行限定了,类似于java/python中的import的功能</p></li></ul><p>下面将以<strong>C++的输入输出流</strong>为例，更好的理解名字空间。</p><br><h2 id="C-的输入输出">C++的输入输出</h2><blockquote><p>除了C标准库的<code>stdio.h</code>中提供的函数<code>scanf()</code>和<code>printf()</code>外，C++自己也有一种输入输出的方式</p></blockquote><h3 id="输入与输出">输入与输出</h3><p><strong>头文件</strong><code>#include&lt;iostream&gt;</code>：</p><ul><li><p><code>cout</code>是一个标准输出流变量（对象），代表控制台窗口</p></li><li><p><code>cin</code>是一个标准输入流变量（对象）</p></li><li><p><code>endl</code>是标准换行符对象，等效于字符中的<code>\n</code>。</p><p>以上三者均需要通过名字空间进行限定才能使用</p></li><li><p><code>std</code>就是 一个<strong>名字空间</strong>，而<code>cout</code>就是名字空间<code>std</code>内部的一个(对象)名字</p><p>使用时需要加上<strong>名字空间限定</strong><code>std::cout</code>(如果之前没有声明的话)</p></li><li><p><code>&lt;&lt;</code>除了作为左移运算符之外，在C++中可作为输出运算符。</p><p>如语句：<code>cout &lt;&lt; x</code> 中，x是一个数据，该语句可以实现“打印”x的数据。</p></li><li><p><code>&gt;&gt;</code>除了作为右移运算符之外，在C++中可作为输入运算符。</p><p>如语句：<code>cin &gt;&gt; x</code> 中，x是一个变量，该语句可以实现“输入”并对x赋值。</p></li></ul><p>~<code>cout</code>和<code>cin</code>可以看出其实就是c-plus-output和c-plus-input即输出与输入的缩写~</p><br><blockquote><p>举例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">//C++标准输出流头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">	std::cout &lt;&lt; x; <span class="comment">//使用std内的cout对x进行输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finish\n&quot;</span>; <span class="comment">//使用std内的cout对字符串进行输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A New Row&quot;</span> &lt;&lt; std::endl;<span class="comment">// 使用std内的endl完成换行的输出</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">//C++标准输出流头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;<span class="comment">//声明cout在std名字空间内，注意有分号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用std内的cout对x进行输出</span></span><br><span class="line">	cout &lt;&lt; x;<span class="comment">//这里直接使用cout即可</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;finish&quot;</span> &lt;&lt; std::endl;<span class="comment">//想要用endl实现换行功能，还得使用空间限定</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">//C++标准输出流头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">//声明使用std名字空间内所有的名字，注意有分号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;哈哈哈！&quot;</span> &lt;&lt; endl;<span class="comment">//使用std内的cout和endl，且不再进行限定了</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;嘿嘿！&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述例子中，我们领会到了名字空间的使用，也不难发现，<strong>输出流</strong>可以串起来使用！</p><p>如：<code>cout &lt;&lt; &quot;finish&quot; &lt;&lt; std::endl;</code></p><p>而 <strong>输入</strong>的使用如下，输入同样也能够实现连续输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x ;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">	cin &gt;&gt; x;  <span class="comment">//注意，此处是两个大于符号</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您刚刚输入的值是：&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>] &gt;&gt; a[<span class="number">2</span>]; <span class="comment">//中间输入时默认要输入空格隔开</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; a[<span class="number">0</span>]+a[<span class="number">1</span>]+a[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅如此，C++还支持有对文件的输入输出……</p><h3 id="初看·文件输入输出">初看·文件输入输出</h3><blockquote><p>此处涉及到之后要学习的 类 和 方法 的知识，可选择性查看</p><p>之后还会再次详细介绍</p></blockquote><p><strong>头文件</strong><code>#include&lt;fstream&gt;</code>：</p><ul><li>类：<code>ofstream</code>输出流对象，以此来实现对文件的输出（类似于c的<code>fprintf</code>）</li><li>类：<code>ifstream</code>输入流对象，以此来实现对文件的输入（类似于c的<code>fscanf</code>）</li><li>方法：<code>xxx.close()</code>通过此方法实现对文件的关闭（类似于c的<code>fclose()</code>）</li></ul><blockquote><p>举例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span> <span class="comment">//文件输入输出头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span><span class="comment">//字符串头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">oF</span><span class="params">(<span class="string">&quot;myfile.txt&quot;</span>)</span></span>;<span class="comment">//以输出的方式 打开/新建 指定路径下的文件 </span></span><br><span class="line">	<span class="type">int</span> x = <span class="number">999</span>;</span><br><span class="line">	oF &lt;&lt; <span class="string">&quot;input some data:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	oF.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="function">ifstream <span class="title">iF</span><span class="params">(<span class="string">&quot;myfile.txt&quot;</span>)</span></span>;<span class="comment">//以输入的方式 打开 指定路径下的文件 </span></span><br><span class="line">	string str1,str2,str3; <span class="comment">//str此时是一个string类对象</span></span><br><span class="line">	iF &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str3;</span><br><span class="line">	iF.<span class="built_in">close</span>();</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="引用变量">引用变量</h2><p><strong>引用变量</strong>是其他变量的别名。如同一个人的外号或小名。<br>既然是引用， <strong>定义引用变量时</strong>就必须指明其引用的变量主体。而且定义之后<strong>不可更改</strong>。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>,b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = a; <span class="comment">//&amp;符号 这里引用变量相当于： 可以用 r 来表示 a</span></span><br><span class="line"><span class="type">int</span> &amp;r = b; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>其本质类似于C中的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="comment">//此时的 *p 就类似于前面的 r 一样，都可以通过对自身的改变从而改变a的值</span></span><br></pre></td></tr></table></figure><p>我们知道，在C语言中，想要使用一个函数来更换a，b的值，不使用指针的方式是无法达到实际更改的。</p><p>具体实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过指针进行交换</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>,b = <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a =&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b =&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a,&amp;b);<span class="comment">//将a,b的地址传给指针</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a =&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b =&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而有了C++的“引用”之后，我们能够得到一种新的解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过&amp;符号，将a,b用x,y进行引用，此时x就相当于a,y就相当于b</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>,b = <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a =&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b =&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a =&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b =&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="默认参数-函数重载">默认参数&amp;函数重载</h2><h3 id="默认形参">默认形参</h3><blockquote><p>在真正的<strong>标准C语言</strong>中，是不支持“默认形参”的</p><p>而且，定义变量必须在真正意义上的语句之前。</p><p>如：<code>printf(&quot;你好！\n&quot;);int a = 0;</code>是<strong>不被允许</strong>的！</p><p>此外，<code>for(int i=0;i&lt;5;i++)</code>即在for循环处直接定义变量也是错误的！</p><p>但是在之后更为人性化的C标准修订之后，有些语法是可以通过的，可以说C和C++大致上共通了，所以默认形参在C中也被广泛使用。</p><blockquote><p>关于在C中使用默认形参的方法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pipisorry/article/details/25437893">https://blog.csdn.net/pipisorry/article/details/25437893</a></p></blockquote></blockquote><p>默认参数指的是当<strong>函数调用</strong>时，可以省略传递实参而自动使用的一个默认值。例如，将<code>void wow(int n)</code>设置成n有默认值为1，则函数调用<code>wow()</code>相当于<code>wow(1)</code>。这极大地提高了使用函数的<strong>灵活性</strong>。</p><br><p><strong>==默认形参必须在非默认形参右边，即一律靠右==</strong></p><p>即 形如 <code>void fn(int x=0,int d)</code>的函数定义方法是错误的。</p><br><h3 id="函数重载">函数重载</h3><p>==<strong>C+ +允许同一作用域里有同名的函数，只要它们的形参不同。</strong>==</p><p>函数重载是根据 <strong>函数签名</strong> 实现的，而函数签名则是由函数名与函数形参共同决定，与返回值无关.例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span> <span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>上述两种函数并<strong>不会</strong>发生冲突</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>上述两种函数<strong>会</strong>发生冲突</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>上述两种函数<strong>不会</strong>发生冲突</li></ul><br><h3 id="函数模板">函数模板</h3><p>在上述例子中，我们给出了两个<code>add()</code>函数，可以方便计算<code>int</code>和<code>double</code>型的两数之和，但是需要编写两个重复性的代码，不便于后期修改与处理。</p><p>因此，我们可以通过<strong>函数模板</strong>来实现高效的函数声明与定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了传入类型为<code>T</code>的值，并返回类型为<code>T</code>的返回值。</p><p>使用函数时，通过 <strong>模板实例化</strong>调用函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">double</span>&gt;(<span class="number">3.6</span>,<span class="number">5.7</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>&lt;string&gt;(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>用尖括号框住数据类型，则T就代表该数据类型，此方法类似于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，上面的这个T是不可灵活更改的。</p><br><p>事实上，模板拥有<strong>自动推断</strong>的功能，在上述例子中，我们调用函数时甚至可以不加尖括号，直接调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.6</span>,<span class="number">5.7</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是有歧义性的参数就不可这样省略性使用，如：</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">5.7</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//3 是int型，而5.7是double型</span></span><br></pre></td></tr></table></figure><br><h2 id="动态内存分配">动态内存分配</h2><p>在C中，我们曾经使用<code>malloc</code>函数对变量进行动态内存的分配，而C++中也可以进行这样的操作。</p><p>不仅如此，C++还提供了一种更加便利的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//代替int *p = (int *)malloc(sizeof(int));</span></span><br><span class="line">    *p = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">//代替free(p);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，这是极其简单，甚至有BUG的写法，比较完备的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//申请内存</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//因为可能会申请内存失败，需判断是否成功，保证完备性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">    *p = <span class="number">9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    	<span class="keyword">delete</span> p;</span><br><span class="line">    	p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的动态分配">二维数组的动态分配</h3><br><h2 id="String-Vector">String &amp; Vector</h2><p>在之前的各种示例中，我们多次使用到<code>string</code>这个“变量类型”。其实，这是一个C++中系统内部的class类。（类与C中的结构体类似，之后会有详细解释）</p><h3 id="string基本使用">string基本使用</h3><p>与C中的字符与字符数组组成的字符串有异同，string实例可以通过调用 方法、成员 实现许多功能。所需头文件<code>&lt;string&gt;</code></p><ol><li><p>赋值/初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;hello minecraft&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>以上两种方式都可以创建一个string实例</li></ul></li><li><p>部分方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">size</span>(); <span class="comment">//返回s这个字符串的大小（int）</span></span><br><span class="line">s.<span class="built_in">substr</span>(a,b); <span class="comment">//返回s这个实例对象的第a到b截到的新字符串，类型也是string</span></span><br><span class="line">s.<span class="built_in">find</span>(<span class="string">&quot;xxx&quot;</span>); <span class="comment">//返回int型下标，即s中出现xxx字符串的第一个下标position</span></span><br><span class="line">s.<span class="built_in">insert</span>(pos,<span class="string">&quot;xxx&quot;</span>); <span class="comment">//在s中下标为pos的地方插入字符串&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  s = s1 + s2; </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	将s1与s2拼接在一起得到的新string对象赋给s</span></span><br><span class="line"><span class="comment">  	(此处+号的逻辑是我们之后需要了解的 运算符重载)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  s[<span class="number">4</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">  <span class="comment">/* 下标运算符</span></span><br><span class="line"><span class="comment">与C一样，string对象同样也是字符数组组成的字符串</span></span><br><span class="line"><span class="comment">  	也可以通过下标确切地更改字符串单个字符的内容</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></li></ol><br><h3 id="vector基本使用">vector基本使用</h3><p>vector，向量，类似于C/C++中的数组，但是其长度可以<strong>动态增长</strong>，所需头文件<code>&lt;vector&gt;</code></p><p>又与上面的string(类)有些许不同，vector是一个<strong>类模板</strong>。如，使用<code>vector&lt;int&gt;</code>就能实例化一个<code>int</code>型的vector类(向量)。</p><ol><li><p>赋值/初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v; <span class="comment">//int型空向量</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; v2 = &#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>&#125;; <span class="comment">//double型默认起始长度是3的向量</span></span><br></pre></td></tr></table></figure></li><li><p>方法与成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(x); <span class="comment">//在v向量末尾添加一个数据x</span></span><br><span class="line">v.<span class="built_in">pop_back</span>(); <span class="comment">//删除最后一个数据</span></span><br><span class="line">v.<span class="built_in">size</span>(); <span class="comment">//返回向量此时的长度</span></span><br><span class="line">v.<span class="built_in">resize</span>(n); <span class="comment">//从第一个起，将v向量截断使size为n</span></span><br></pre></td></tr></table></figure></li></ol><br><h2 id="面向对象">面向对象</h2><blockquote><p>在前面的学习中，我们多次提到了 “类”、“对象”等词汇。接下来我们将真正进入面向对象的世界~~</p></blockquote><h3 id="创建类与对象">创建类与对象</h3><blockquote><p>一般在开发中，常常把类的创建独立出来用头文件<code>.h</code>来 “保存” 我们“造的轮子”</p></blockquote><p>通过关键词：class + 自定义的类名 进行类的<strong>创建</strong></p><h4 id="快速开始">快速开始</h4><p><strong>基础示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">	<span class="type">int</span> arr1;</span><br><span class="line">    <span class="type">float</span> arr2;</span><br><span class="line">    <span class="type">char</span> arr3;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">bool</span> flag=flase)</span></span>&#123;<span class="keyword">return</span> x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与C语言的结构体类似，不同的是，类可以将函数也作为内部成员，这种在类里面声明/定义的函数我们一般称之为类的方法。</p><p><strong>使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    ClassName c;</span><br><span class="line">    c.arr1 = <span class="number">1</span>;</span><br><span class="line">    c.<span class="built_in">f</span>();</span><br><span class="line">    c.<span class="built_in">g</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//默认形参使flag=flase</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与C语言的结构体类似，直接通过<code>类名+.+成员</code>调用.</p><h4 id="访问运算符">访问运算符</h4><p>通过访问控制符一定程度上可以保证程序的安全性，灵活使用可以使得类的外部不能轻易使用 <strong>私有属性和方法</strong></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;<span class="comment">//名字作为私有成员，不对外开放</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类的访问控制符有四种：</p></blockquote><ul><li><p><code>public</code></p><p>可以通过外部访问方式访问类内部的public成员</p></li><li><p><code>private</code></p><p>不能通过外部访问方式访问类内部的private成员</p></li><li><p><code>protected</code></p><p>不可以通过外包访问方式访问类内部的protected成员</p></li><li><p>默认【即不加任何修饰符<code>default</code>】</p></li></ul><p><strong>在一个类的内部，所有的成员可以相互访问,访问控制符是透明的;访问控制符是针对外部而言的</strong></p><blockquote><p>外部访问包括两种方式：</p></blockquote><ul><li>通过<strong>类名</strong>访问类内部的成员</li><li>通过<strong>类对象名</strong>访问类内部成员</li></ul><p><strong>==更多访问控制符的使用我们将在继承与包的学习中再次提及==</strong></p><hr><h4 id="规范书写">规范书写</h4><p>一般，我们将函数方法作为public成员，而变量成员作为private成员。下面给出C++类创捷的规范书写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> arr1;</span><br><span class="line">    <span class="type">char</span> arr2;</span><br><span class="line">    string arr3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassName</span>();</span><br><span class="line">    ~<span class="built_in">ClassName</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(<span class="type">int</span>,<span class="type">char</span>,string)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候就会产生疑问了。规范书写的<code>ClassName()</code>和<code>~ClassName()</code>是什么？</p><p>如果是变量成员为什么有括号？如果是函数为什么没有返回值？而且为什么名字和类名一模一样？</p><p>这就是 构造函数和析构函数!</p><br><h3 id="构造函数">构造函数</h3><p>malloc不会使用构造函数</p><h3 id="析构函数">析构函数</h3><h3 id="参数化表">参数化表</h3><p>参数化表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CBox</span>(<span class="type">int</span> l=<span class="number">10</span>,<span class="type">int</span> w=<span class="number">20</span>,<span class="type">int</span> h=<span class="number">30</span>):<span class="built_in">l</span>(l),</span><br><span class="line">                              <span class="built_in">w</span>(w),</span><br><span class="line">                              <span class="built_in">h</span>(h)</span><br></pre></td></tr></table></figure><h3 id="this指针">this指针</h3><h2 id="抽象、封装与信息隐藏">抽象、封装与信息隐藏</h2><h3 id="普通常量">普通常量</h3><blockquote><p><strong>常量</strong>（<code>const</code>）：共用数据的保护</p><p>使得数据能够在一定范围内共享，又保证数据不被任意修改</p></blockquote><h4 id="常对象">常对象</h4><ul><li><p><strong>功能</strong>：常对象数据成员的值是常量，不能修改</p></li><li><p><strong>格式</strong>：</p><ul><li><code>类名 const 对象名[(实参表)]</code></li><li><code>const 类名 对象名[(实参表)]</code></li></ul></li></ul><ul><li><strong>说明</strong>：</li></ul><p><strong>1</strong>）常对象必须进行初始化，而且不能被更新;</p><p><strong>2</strong>）常对象不能调用该常对象的非<code>const</code>型的成员函数；除非把要调用的成员函数定义为常成员函数<code>const</code>.</p><p>【避免非<code>const</code>型的成员函数修改常对象中的数据成员的值，因为<code>const</code>型的成员函数不能修改对象中的数据成员的值】</p><ul><li><strong>举例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Time</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> hour;</span><br><span class="line">	<span class="type">int</span> minute;</span><br><span class="line">	<span class="type">int</span> sec;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_time</span><span class="params">( )</span></span>;  </span><br><span class="line">&#125;;</span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s)&#123;</span><br><span class="line">	hour=h;</span><br><span class="line">	minute=m;</span><br><span class="line">	sec=s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::get_time</span><span class="params">( )</span> </span>&#123;cout&lt;&lt;hour&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;minute&lt;&lt;<span class="string">&quot;:&quot;</span> &lt;&lt;sec&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">	Time t1(10,15,36); </span></span><br><span class="line"><span class="comment">	t1.get_time( );</span></span><br><span class="line"><span class="comment">	t1.hour=20;   //可以修改对象中数据成员的值</span></span><br><span class="line"><span class="comment">	t1.get_time( );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">	const Time t1(10,15,36); //利用const定义常对象</span></span><br><span class="line"><span class="comment">	t1.get_time( ); //常对象不能调用该常对象的非const型的成员函数；除非把要调用的成员函数定义为常成员函数const</span></span><br><span class="line"><span class="comment">	t1.hour=20;//以上均error</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="常函数">常函数</h4><p>前面的示例代码中，我们提到：</p><blockquote><p>常对象不能调用该常对象的非const型的成员函数；除非把要调用的成员函数定义为常成员函数const</p></blockquote><p>也就是说，函数也是可以定义为常函数的。</p><ul><li><p><strong>格式</strong></p></li><li><p><code>&lt;返回值类型&gt; &lt;函数名&gt; (&lt;参数表&gt;) const &#123;代码块&#125;</code></p></li><li><p><strong>注意</strong></p><p><strong>常成员函数不能调用另外一个非cosnt成员函数</strong></p></li></ul><hr><p>有时在编程时有要求，一定要修改常对象成员中的某个数据成员的值（例如类中有一个用于计数的变量<code>count</code>，其值应当不能变化）此时可把该数据成员声明为<strong>mutable</strong>，如：<br><code>mutable int count;</code> : 定义一个在常对象中可以被改变的数据成员<br>把<code>count</code>声明为可变的数据成员，这样就可以用声明为<code>const</code>的成员函数来修改它的值。</p><ul><li>再<strong>举例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> n,<span class="type">float</span> s):<span class="built_in">num</span>(n),<span class="built_in">score</span>(s)&#123;&#125;<span class="comment">//语句0</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> n,<span class="type">float</span> s)</span> <span class="type">const</span></span>&#123;num=n;score=s;&#125;<span class="comment">//语句1</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>&#123;cout&lt;&lt;num&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;score&lt;&lt;endl;&#125;<span class="comment">// 语句2</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> num;<span class="comment">//语句3</span></span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">float</span> score;<span class="comment">//语句4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="type">const</span> <span class="title">stud</span><span class="params">(<span class="number">101</span>,<span class="number">78.5</span>)</span></span>;<span class="comment">//语句5</span></span><br><span class="line">	stud.<span class="built_in">display</span>();</span><br><span class="line">	stud.<span class="built_in">change</span>(<span class="number">101</span>,<span class="number">80.5</span>);</span><br><span class="line">	stud.<span class="built_in">display</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>语句0：利用参数化表的形式编写构造函数，这样可以对<code>const</code>的对象进行初始化</li><li>语句1&amp;语句2：将成员函数设置为<code>const</code>型函数常量，这样可以通过<code>const</code>的对象调用</li><li>语句3&amp;语句4：将成员变量设置为<code>mutable</code>类型，这样可以使得<code>const</code>型函数对其进行修改</li><li>语句5：先定义一个<code>const</code>的类对象，然后对应于语句0可以进行初始化</li></ol><h4 id="常成员">常成员</h4><ul><li><strong>格式</strong>： <code>const &lt;类型&gt; &lt;数据成员变量名&gt;</code><br>例： <code>const int hour;</code></li><li><strong>说明</strong>：只能通过构造函数的<strong>参数初始化表</strong>对常数据成员进行初始化。任何地方都不能使用赋值语句对常数据成员赋值。</li></ul><p>在类体中声明了某一个数据成员为常数据成员后，该类所有对象中的该数据成员的值都是不能改变的，但不同对象中该变量成员的值可以是不同的（分别在初始化时指定）</p><ul><li><strong>举例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Time</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> hour;</span><br><span class="line">	<span class="type">int</span> minute;</span><br><span class="line">	<span class="type">int</span> sec;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">get_time</span><span class="params">( )</span> <span class="type">const</span></span>;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*因为hour是const，所以不能使用这种方式初始化</span></span><br><span class="line"><span class="comment">Time::Time(int h,int m,int s)&#123;</span></span><br><span class="line"><span class="comment">	hour=h;</span></span><br><span class="line"><span class="comment">	minute=m;</span></span><br><span class="line"><span class="comment">	sec=s;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s):<span class="built_in">hour</span>(h),<span class="built_in">minute</span>(m),<span class="built_in">sec</span>(s)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::get_time</span><span class="params">()</span> <span class="type">const</span> </span>&#123;cout&lt;&lt;hour&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;minute&lt;&lt;<span class="string">&quot;:&quot;</span> &lt;&lt;sec&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">10</span>,<span class="number">15</span>,<span class="number">36</span>)</span></span>; </span><br><span class="line"><span class="comment">//	t1.hour=20;//常数据成员的值不能修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结">总结</h4><p><img src="excel1.png" alt="作用表"></p><ol><li>如果在一个类中，有些数据成员的值允许改变，另一些数据成员的值不允许改变，则可以将一部分数据成员声明为<code>const</code>，以保证其值不被改变，可以用非<code>const</code>的成员函数引用这些数据成员的值，并修改非<code>const</code>数据成员的值。</li><li>如果要求所有的数据成员的值都不允许改变，则可以将所有的数据成员声明为<code>const</code>，或将对象声明为<code>const</code>(常对象)，然后用<code>const</code>成员函数引用数据成员，这样起到“双保险”的作用，切实保证了数据成员不被修改。</li><li>不要误认为常对象中的成员函数都是常成员函数，常对象只保证其所有数据成员的值不被修改。</li><li>如果在常对象中的成员函数未加<code>const</code>声明，则编译系统会把它当<code>非const</code>成员函数处理。</li><li>常成员函数不能调用另外一个<code>非cosnt</code>成员函数。</li></ol><br><h3 id="指针常量">指针常量</h3><ul><li><strong>定义</strong><br>将指向对象的指针变量声明为<code>const</code>型，指针值（地址）不变【编号不变】。（地址指向的内存中的内容可以改变）。</li><li><strong>格式</strong><br><code>&lt;类名&gt; * const &lt;指针变量名&gt;;</code></li><li><strong>举例</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;a;</span><br><span class="line"><span class="type">int</span>* q = &amp;b;</span><br><span class="line">*p = <span class="number">5</span>;<span class="comment">//没问题，之后a的值为5</span></span><br><span class="line">p = q;<span class="comment">//报错，p保存的地址不能更改</span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>可以保证指针的值不被改变，维护了安全性</li></ul></li></ul><h3 id="常量指针">常量指针</h3><ul><li><p><strong>格式</strong>：定义指向常对象的指针变量的一般形式</p><ul><li><code>const &lt;类名&gt;* &lt;指针变量名&gt;;</code></li></ul></li><li><p><strong>说明</strong>：</p><ol><li><p>如果一个对象已被声明为常对象，只能用指向常对象的指针变量指向它</p><p>而不能用一般的 (指向<code>非const</code>型对象的) 指针变量去指向它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="type">const</span> <span class="title">t</span><span class="params">(<span class="number">12</span>,<span class="number">45</span>,<span class="number">45</span>)</span></span>;</span><br><span class="line">Time *p = &amp;t;<span class="comment">//报错，不能指向常对象</span></span><br><span class="line"><span class="type">const</span> Time *q = &amp;t;<span class="comment">//成功</span></span><br></pre></td></tr></table></figure></li><li><p>如果定义了一个指向常对象的指针变量，并使它指向一个<code>非const</code>的对象，则其指向的对象是不能通过指针来改变的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">t</span><span class="params">(<span class="number">12</span>,<span class="number">45</span>,<span class="number">45</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> Time *p = &amp;t;</span><br><span class="line">t.<span class="built_in">ChangeHour</span>(<span class="number">11</span>);<span class="comment">//报错，指向t之后，t不能再改变了</span></span><br></pre></td></tr></table></figure></li><li><p>指向常对象的指针最常用于函数的形参，目的是在保护形参指针所指向的对象，使它在函数执行过程中不被修改</p></li></ol></li></ul><br><h3 id="常引用">常引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line">    <span class="type">int</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s)&#123;  <span class="comment">//定义构造函数</span></span><br><span class="line">    hour=h;</span><br><span class="line">    minute=m;</span><br><span class="line">    sec=s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******原始版本******/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Time &amp;t)</span></span>&#123;t.hour=<span class="number">18</span>;&#125;  </span><br><span class="line"><span class="comment">//形参t是Time类对象的引用 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******优化版本******/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> Time &amp;t)</span></span>&#123;t.hour=<span class="number">18</span>;&#125;    </span><br><span class="line"><span class="comment">//形参t是Time类对象的引用 </span></span><br><span class="line"><span class="comment">//保证t指向的对象不能被改变，保证安全性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">10</span>,<span class="number">13</span>,<span class="number">56</span>)</span></span>;   <span class="comment">// t1是Time类对象</span></span><br><span class="line">    <span class="built_in">fun</span>(t1);             <span class="comment">//实参是Time类对象，可以通过引用来修改实参t1的值</span></span><br><span class="line">    cout&lt;&lt;t1.hour&lt;&lt;endl; <span class="comment">//输出t1.hour的值为18</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>经常用常指针和常引用作函数参数。这样既能保证数据安全，使数据不能被随意修改，在调用函数时又不必建立实参的拷贝。用常指针和常引用作函数参数，可以提高程序运行效率。</strong></p><hr><h3 id="静态成员">静态成员</h3><blockquote><p>目的：在<strong>同类</strong>的多个对象之间实现数据共享，不用全局对象，而用<strong>静态</strong>的数据成员。（例：学生类中的平均分、最高分等）</p></blockquote><p><strong>静态成员</strong>是同一个类中所有对象共享的成员，不是某一对象的成员。</p><p>用静态数据成员可以节省内存，是<strong>所有对象所公有的</strong>，对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p><p>静态数据成员的值对每个对象都是一样，它的值是可以更新的。静态数据成员是静态存储的，具有静态生存期。</p><p><img src="excel2.png" alt="存储方式"></p><ul><li><strong>声明</strong>：通过关键词<code>static</code>对成员进行声明<ul><li>如：<code>static float num;</code></li></ul></li><li><strong>初始化</strong>：一般情况下，类的静态成员不能直接在声明的时候赋予初值，要在类外部实现<ul><li><code>float ClassName::num = 10;</code></li><li><code>&lt;变量类型&gt; &lt;类名&gt;::&lt;变量名&gt; = &lt;初始值&gt;;</code></li><li>即 无需再加<code>static</code>关键词</li></ul></li><li><strong>使用</strong>：<ul><li>通过生成的实例对象名引用：<code>&lt;对象名&gt;.&lt;静态成员名&gt;</code></li><li>通过类名引用静态数据：<code>&lt;类名&gt;::&lt;静态成员名&gt;</code></li></ul></li></ul><h3 id="静态成员函数">静态成员函数</h3><blockquote><p>目的：使用静态成员函数引用静态数据成员</p></blockquote><ul><li><p><strong>声明/定义</strong>：例子：<code>static void print();</code></p></li><li><p><strong>说明</strong>：</p><ol><li><p>静态成员函数属于类的静态成员，不是对象成员。对静态成员的引用<strong>不需要用对象名</strong></p></li><li><p>在静态成员函数的实现中不能直接引用类中说明的<strong>非静态成员</strong>，可以引用类中说明的静态成员。</p><p>如果静态成员函数中要引用非静态成员时，可通过对象来引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态成员函数内部：</span></span><br><span class="line">cout&lt;&lt;height&lt;&lt;endl;   <span class="comment">//height为static，引用本类中的静态成员，合法</span></span><br><span class="line">cout&lt;&lt;width&lt;&lt;endl;    <span class="comment">//width是非静态数据成员，不合法</span></span><br><span class="line">cout&lt;&lt;a.width&lt;&lt;endl;    <span class="comment">//引用本类对象a中的非静态成员</span></span><br></pre></td></tr></table></figure></li><li><p><strong>公有的静态成员函数既可以有通过相应的对象访问，也可以通过其所属的类名来引用。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box::<span class="built_in">print</span>();<span class="comment">//合法</span></span><br><span class="line">box1.<span class="built_in">print</span>();<span class="comment">//也合法</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>实例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="友元函数">友元函数</h3><blockquote><p>类外访问公用成员(public);只有本类中的函数可以访问本类的私有成员(private);<br>特例：友元(friend)可以访问与其有好友关系的类中的私有成员(private).</p></blockquote><ul><li>定义：<br>在类的声明语句中的public部分加入<code>friend &lt;返回类型&gt; &lt;其他地方的函数名&gt;(&lt;参数表&gt;)</code><br>则该函数可以访问类中的私有成员（private）</li><li>使用:<br>1）将普通函数声明为友元函数</li></ul><h3 id="类模板">类模板</h3><p>在前面的学习中，我们给出了C++标准库中的<code>vector</code>的基本使用。如想要创建<code>int</code>型的向量组，仅需通过以下语句定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>之后我们学习到类之后，我们可以发现，vector就是一个类，我们通过类的实例创建的方式得到了名字为<code>a</code>的对象。</p><p>那么，<code>&lt;int&gt;</code>又代表什么呢？这将是接下来要讲的 <strong>类模板</strong>。</p><hr><h2 id="运算符重载">运算符重载</h2><p>以下均以 “复数类模板” 作为例子一一介绍运算符重载极其优势</p><h3 id="单目">单目</h3><h3 id="输入输出流重载">输入输出流重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">复数类模板 </span></span><br><span class="line"><span class="comment">real为实部;</span></span><br><span class="line"><span class="comment">img为虚部.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_dReal;</span><br><span class="line">    <span class="type">double</span> m_dImg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>();</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r,<span class="type">double</span> i);</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">const</span> Complex &amp;c);<span class="comment">//通过引用进行对象拷贝</span></span><br><span class="line">    ~<span class="built_in">Complex</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Disp</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;output,Complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*部分函数实现已省略*/</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;output,Complex &amp;c)&#123;</span><br><span class="line">    output &lt;&lt; c.m_dReal;</span><br><span class="line">    <span class="keyword">if</span>(c.m_dImg &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        output &lt;&lt; <span class="string">&#x27;+&#x27;</span> &lt;&lt; c.m_dImg;</span><br><span class="line">    &#125;</span><br><span class="line">    output &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承">继承</h2><blockquote><p><strong>继承好处</strong></p><p>解决软件重用（software reuseablility）问题，可以利用已有的软件资源，节约人力、物力、财力、时间，效率高</p><p><strong>定义</strong></p><p>继承是使用已存在的类的定义作为基础建立新类的技术.</p><p>新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p><p>通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。</p><p>（1）子类拥有父类<strong>非private</strong>的属性和方法。</p><p>（2）子类可以拥有自己属性和方法，即子类可以对父类<strong>进行扩展</strong>。</p><p>（3）子类可以用自己的方式实现父类的方法。（多态）</p></blockquote><h3 id="继承方式">继承方式</h3><p>用于规定派生类中由基类继承到的那部分成员在派生类中的<strong>访问控制</strong>权限。</p><p>继承方式用下述三个关键字之一来指定：public：公有继承；protected：保护继承；private：私有继承。</p><p><strong>注：构造函数和析构函数不能被继承</strong></p><p>下面给出不同继承方式的差异对比：</p><table><thead><tr><th>继承方式</th><th>基类中访问权限</th><th>派生类中访问权限</th></tr></thead><tbody><tr><td><strong>公有继承</strong></td><td>public</td><td>public</td></tr><tr><td></td><td>protected</td><td>protected</td></tr><tr><td></td><td>private</td><td>不可访问</td></tr><tr><td><strong>私有继承</strong></td><td>public</td><td>private</td></tr><tr><td></td><td>protected</td><td>private</td></tr><tr><td></td><td>private</td><td>不可访问</td></tr><tr><td><strong>保护继承</strong></td><td>public</td><td>protected</td></tr><tr><td></td><td>protected</td><td>protected</td></tr><tr><td></td><td>private</td><td>不可访问</td></tr></tbody></table><h3 id="子类的构造函数">子类的构造函数</h3><p>构造函数不能被继承，<strong>只能通过调用</strong>！！</p><p>逻辑：构造函数初始化过程是从父类“向外”<strong>扩散</strong>的，也就是从父类开始向子类一级一级地完成初始化。</p><p>两种情况：</p><p>（1）自动调用父类构造函数：父类有默认构造函数</p><p>（2）明显的调用父类构造函数：父类没有默认构造函数。C++中要求在子类的构造函数中，使用<strong>参数化表</strong>的方式，调用父类没有默认构造函数</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   	<span class="built_in">Student</span>();</span><br><span class="line">   	<span class="built_in">Student</span>(<span class="type">int</span> n,string na);</span><br><span class="line">   	~<span class="built_in">Student</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_iNum;</span><br><span class="line">    string m_strName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类Graduate用public方式继承自Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graduate</span>:<span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//新增成员</span></span><br><span class="line">    <span class="type">float</span> f_Score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graduate</span>();</span><br><span class="line">    <span class="comment">//原句:Graduate(int n,string na,float s);</span></span><br><span class="line">    <span class="built_in">Graduate</span>(<span class="type">int</span> n,string na,<span class="type">float</span> s):<span class="built_in">Student</span>(na,n),<span class="built_in">f_Score</span>(s)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Graduate</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>()&#123;</span><br><span class="line">    i_Num = <span class="number">0</span>;</span><br><span class="line">    str_Name = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student::<span class="built_in">Student</span>(string na,<span class="type">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i_Num = n;</span><br><span class="line">    <span class="keyword">this</span>-&gt;str_Name = na;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::display</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;str_Name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;i_Num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Student::~<span class="built_in">Student</span>(<span class="type">void</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">Graduate::<span class="built_in">Graduate</span>()&#123;</span><br><span class="line">    <span class="comment">//子类事实上会在此处自动调用父类的无参构造函数</span></span><br><span class="line">    <span class="comment">//即：Student::Student();</span></span><br><span class="line">    f_Score = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 原句:会报错</span></span><br><span class="line"><span class="comment">Graduate::Graduate(int n,string na,float s)&#123;</span></span><br><span class="line"><span class="comment">	this-&gt;i_Num = n;</span></span><br><span class="line"><span class="comment">    this-&gt;str_Name = na;</span></span><br><span class="line"><span class="comment">    this-&gt;f_Score = s;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">Graduate::~<span class="built_in">Graduate</span>()&#123;&#125;</span><br><span class="line"><span class="comment">//重写子类的display函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graduate::display</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    Student::<span class="built_in">display</span>();</span><br><span class="line">    cout &lt;&lt; f_Score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承时的构造原则：</strong></p><p>1）如果子类没有定义构造函数，那子类就是调用父类的无参数的构造函数。</p><p>2）如果子类定义了构造函数，那么不管父类有没有定义构造函数，在创建子类对象时，首先会调用父类的无参数的构造函数，然后在调用子类自己的构造函数。</p><p>3）在创建一个子类对象时，如果子类没有显示调用父类的构造函数，那么就会首先调用父类的默认的无参的构造函数（其实和上面的2是一样的）。</p><p>4）在创建子类对象时，如果此时父类有自己书写了无参的构造函数，此时如果子类没有显示的调用父类的构造函数，那就就会首先调用父类自己书写的的无参的构造函数。</p><p>5）在创建子类对象时，如果父类只有有参的构造函数，子类没有显示的调用的父类的构造函数，则会出错。因为如果父类只有有参的构造函数，那么子类就必须显示调用父类有参的构造函数，</p><p>6）如果子类显示调用父类的有参构造函数，那么必须使用初始化列表形式进行初始化。</p><h3 id="子类对象的内存模型">子类对象的内存模型</h3><p><img src="module.png" alt="继承模型"></p><h4 id="赋值兼容规则">赋值兼容规则</h4><blockquote><p>公有继承下的赋值兼容规则</p></blockquote><p>公有派生类的对象可赋给其基类对象，基类对象不能赋给派生类对象的规则，称为赋值兼容规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//已知：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1）派生类对象可以向基类对象赋值。</p><ul><li></li><li></li></ul><p>2）派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化。</p><p>3）如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象。</p><p>4）派生类对象的地址可以赋给指向基类对象的指针变量，也就是说，指向基类对象的指针变量也可以指向派生类对象</p><h3 id="多重继承">多重继承</h3><h2 id="多态">多态</h2><h3 id="虚函数">虚函数</h3><h2 id="异常处理">异常处理</h2><h2 id="推荐资料">推荐资料</h2><p>1.《数学之美》</p><p>2.C与C++的变量、函数与常量_by刘俊</p><p>3.Matrix/Complex封装实例</p><h2 id="参考资料">参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16t411h7bD">1.C++快速入门|HWDONG-Bilbili</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pipisorry/article/details/25437893">2.C语言默认参数值的实现|CSDN</a></p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++|从C到C++快速入门</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://qslie.top/posts/faf498b7/">https://qslie.top/posts/faf498b7/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Slie</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2020-06-19</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-03-11</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80/">语言</a></div><div class="post_share"><div class="social-share" data-image="https://z3.ax1x.com/2021/04/17/c5P76I.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">打赏</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png"></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png"></a><div class="post-qr-code-desc"></div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.16/audio/coin.mp3"></audio><script defer src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/6f1b86a3/" title="常见网络命令|计网基础Ⅰ"><img class="cover" src="https://z3.ax1x.com/2021/04/17/c5iSpj.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常见网络命令|计网基础Ⅰ</div></div></a></div><div class="next-post pull-right"><a href="/posts/5ce0d4ea/" title="DS简介与线性表|数据结构Ⅰ"><img class="cover" src="https://z3.ax1x.com/2021/04/17/c5iSpj.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DS简介与线性表|数据结构Ⅰ</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/04/09/Likong.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Slie</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sliefamily"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=1hPHFQqPhpkbBVYbFjRC4q8YQ-A72EFL&amp;noverify=0" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/SlieFamily" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sliewdyinwhite@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">秘密基地被发现啦！QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0C"><span class="toc-number">1.</span> <span class="toc-text">简述C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">标准库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">C++的输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">3.1.</span> <span class="toc-text">输入与输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E7%9C%8B%C2%B7%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">3.2.</span> <span class="toc-text">初看·文件输入输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">引用变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">默认参数&amp;函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%BD%A2%E5%8F%82"><span class="toc-number">5.1.</span> <span class="toc-text">默认形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.3.</span> <span class="toc-text">函数模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.</span> <span class="toc-text">动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">6.1.</span> <span class="toc-text">二维数组的动态分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Vector"><span class="toc-number">7.</span> <span class="toc-text">String &amp; Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">string基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">vector基本使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.</span> <span class="toc-text">创建类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="toc-number">8.1.1.</span> <span class="toc-text">快速开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.1.2.</span> <span class="toc-text">访问运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E4%B9%A6%E5%86%99"><span class="toc-number">8.1.3.</span> <span class="toc-text">规范书写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8"><span class="toc-number">8.4.</span> <span class="toc-text">参数化表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">8.5.</span> <span class="toc-text">this指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E4%B8%8E%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F"><span class="toc-number">9.</span> <span class="toc-text">抽象、封装与信息隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%B8%B8%E9%87%8F"><span class="toc-number">9.1.</span> <span class="toc-text">普通常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.1.1.</span> <span class="toc-text">常对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.2.</span> <span class="toc-text">常函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%88%90%E5%91%98"><span class="toc-number">9.1.3.</span> <span class="toc-text">常成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">9.2.</span> <span class="toc-text">指针常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="toc-number">9.3.</span> <span class="toc-text">常量指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-number">9.4.</span> <span class="toc-text">常引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">9.5.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.6.</span> <span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">9.7.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">9.8.</span> <span class="toc-text">类模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">10.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%9B%AE"><span class="toc-number">10.1.</span> <span class="toc-text">单目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E9%87%8D%E8%BD%BD"><span class="toc-number">10.2.</span> <span class="toc-text">输入输出流重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">11.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">子类的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.3.</span> <span class="toc-text">子类对象的内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99"><span class="toc-number">11.3.1.</span> <span class="toc-text">赋值兼容规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">11.4.</span> <span class="toc-text">多重继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">12.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.1.</span> <span class="toc-text">虚函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99"><span class="toc-number">14.</span> <span class="toc-text">推荐资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">15.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d3d469f8/" title="Docker - 一步到位的应用部署与上线"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/docker.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Docker - 一步到位的应用部署与上线"></a><div class="content"><a class="title" href="/posts/d3d469f8/" title="Docker - 一步到位的应用部署与上线">Docker - 一步到位的应用部署与上线</a><time datetime="2024-03-05T07:11:45.000Z" title="发表于 2024-03-05 15:11:45">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1bb1ae1/" title="GFS - 谷歌的分布式文件存储系统"><img src="http://img.49you.com/20170303/58b8d6f32d651.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="GFS - 谷歌的分布式文件存储系统"></a><div class="content"><a class="title" href="/posts/c1bb1ae1/" title="GFS - 谷歌的分布式文件存储系统">GFS - 谷歌的分布式文件存储系统</a><time datetime="2024-03-05T04:04:07.000Z" title="发表于 2024-03-05 12:04:07">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f21b6bc8/" title="HuskyLab Servers 0x519 操作指南【自用】"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/husklab_bg.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="HuskyLab Servers 0x519 操作指南【自用】"></a><div class="content"><a class="title" href="/posts/f21b6bc8/" title="HuskyLab Servers 0x519 操作指南【自用】">HuskyLab Servers 0x519 操作指南【自用】</a><time datetime="2024-03-04T13:29:31.000Z" title="发表于 2024-03-04 21:29:31">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7dae821/" title="【快速入门】集群资源管理调度系统 - Slurm"><img src="https://gitee.com/sliewdy/ImageURL-slie/raw/master/imagesNoT/QQ%E5%9B%BE%E7%89%8720210414005713.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【快速入门】集群资源管理调度系统 - Slurm"></a><div class="content"><a class="title" href="/posts/f7dae821/" title="【快速入门】集群资源管理调度系统 - Slurm">【快速入门】集群资源管理调度系统 - Slurm</a><time datetime="2024-03-04T12:50:38.000Z" title="发表于 2024-03-04 20:50:38">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8cb817a9/" title="【最优化】Levenberg-Marquardt 算法"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202401051550627.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【最优化】Levenberg-Marquardt 算法"></a><div class="content"><a class="title" href="/posts/8cb817a9/" title="【最优化】Levenberg-Marquardt 算法">【最优化】Levenberg-Marquardt 算法</a><time datetime="2023-12-22T03:07:39.000Z" title="发表于 2023-12-22 11:07:39">2023-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://z3.ax1x.com/2021/04/17/c5P76I.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Slie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to Chaos World!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("/pluginsSrc/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" href="/pluginsSrc/katex/dist/katex.min.css"><script src="/pluginsSrc/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{btf.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("/pluginsSrc/mermaid/dist/mermaid.min.js").then(t)};btf.addModeChange("mermaid",t),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.qslie.top/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.qslie.top/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.textContent=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script async src="/js/diytitle.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script async src="/js/diytitle.js"></script><script data-pjax defer src="/js/fixed_comment.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/pluginsSrc/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 算法相关，编程实现 (60)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/故事/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 杂谈日志，光影记录 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/日常/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 记忆碎片，梦境显影 (36)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/机器学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💻 机器学习，数学规划 (35)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://qslie.top/tags" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4f5fd499/" alt=""><img width="48" height="48" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/20231030204417.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/4f5fd499/" alt="">Deep Neural Net | 多层感知机与神经网络入门</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="posts/4f5fd499/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/9a95977b/" alt=""><img width="48" height="48" src="math-cover.jfif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/9a95977b/" alt="">SLie的&quot;数学基础&quot;集装箱|Perhaps.Ver1.04</a><div class="blog-slider__text">好了，你已经学会1+1=2了，下面来证明一下广义黎曼猜想吧~</div><a class="blog-slider__button" href="posts/9a95977b/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4ea9ab3c/" alt=""><img width="48" height="48" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main/Auto/202202232045587.jpeg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/4ea9ab3c/" alt="">算法分析与设计 &amp; 本站算法综述</a><div class="blog-slider__text">本文罗列了常见的经典问题和算法，以及主要的算法分析方法和设计方法</div><a class="blog-slider__button" href="posts/4ea9ab3c/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/5ebaa4d9/" alt=""><img width="48" height="48" src="https://gitee.com/sliewdy/ImageURL-slie/raw/master/imagesNoT/QQ%E5%9B%BE%E7%89%8720210414005713.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/5ebaa4d9/" alt="">捣鼓程序时的各种【踩坑】【报错】全收录</a><div class="blog-slider__text">配置环境、安装库包等网上冲浪时遇见到的各式各样奇奇怪怪的Warning和Error，以及各种治标不治本或者又治标又治本的解决方案全记录（个人向）</div><a class="blog-slider__button" href="posts/5ebaa4d9/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>