<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Java自学入门|笔记实录 | SLie's Blog|琴弦之轮</title><meta name="author" content="Slie"><meta name="copyright" content="Slie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言：本文章对于java的入门学习基于有C&amp;#x2F;C++以及python基础，部分重叠的基础知识可能有大量删减  Java简述 跳过简述|直接莽干 简单易学  Java最初是为对家用电器进行集成控制而设计的一种语言，因此它必须简单明了。  Java语言的简单性主要体现在四个方面: ​	1、Java的风格类"><link rel="shortcut icon" href="/img/%E7%A3%81%E5%B8%A6.png"><link rel="canonical" href="https://qslie.top/posts/99aebcb8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:{limitDay:90,position:"top",messagePrev:"本文章距离上次修改已经过了",messageNext:"天，相关内容可能不再适用，请留意."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-center"},source:{justifiedGallery:{js:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js",css:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Java自学入门|笔记实录",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-03-11 22:44:06"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/fixed_comment.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/twikoo_beautify.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/04/09/Likong.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>声影</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/films/"><i class="fa-fw fas fa-video"></i> <span>映像</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>图书</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://z3.ax1x.com/2021/04/17/c5P76I.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="SLie's Blog|琴弦之轮"><span class="site-name">SLie's Blog|琴弦之轮</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>声影</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/films/"><i class="fa-fw fas fa-video"></i> <span>映像</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>图书</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java自学入门|笔记实录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-22T13:58:34.000Z" title="发表于 2020-09-22 21:58:34">2020-09-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-11T14:44:06.505Z" title="更新于 2024-03-11 22:44:06">2024-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/">计算机科学与技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/Java%E7%B3%BB%E5%88%97/">Java系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Java自学入门|笔记实录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image:url(https://z3.ax1x.com/2021/04/17/c5P76I.jpg)"></div><article class="post-content" id="article-container"><p><em><strong>前言：本文章对于java的入门学习基于有C/C++以及python基础，部分重叠的基础知识可能有大量删减</strong></em></p><br><h2 id="Java简述">Java简述</h2><p><a href="#skip1">跳过简述|直接莽干</a></p><h3 id="简单易学">简单易学</h3><blockquote><p>Java最初是为对家用电器进行集成控制而设计的一种语言，因此它必须简单明了。</p></blockquote><p>Java语言的<strong>简单性</strong>主要体现在四个方面:</p><p>​ 1、Java的风格类似于C++，从某种意义上讲，Java语言是C及C++语言的一个变种因而C++程序员初次接触Java语言，就会感到很熟悉。</p><p>​ 2、Java<strong>摒弃</strong>了C/C++中容易引发程序错误并且难以掌握的一些特性，如指针、结构、以及<strong>内存管理</strong>等。</p><p>​ 3、Java<strong>提供</strong>了丰富的<strong>类库</strong>，可以帮助我们很方便的开发Java程序。</p><h3 id="安全性高">安全性高</h3><p>​ 1、java是一种<strong>强类型</strong>的语言，其类型检查比C/C++还要严格。类型检查帮助我们检查出许多开发早期出现的错误</p><p>​ 2、java提供了<strong>垃圾回收机制</strong>，有效的避免了C/C++中最头疼的<strong>内存泄漏问题</strong></p><p>​ 3、java<strong>禁止非法内存访问</strong>，在没有授权的情况下是不能访问内存的.所有这些措施，使Java程序员不用再担心内存的崩溃</p><h3 id="跨平台">跨平台</h3><blockquote><p>Java作为一种<strong>网络语言</strong>，其源代码被编译成一种结构中立的中间文件格式。</p><p>只要有Java运行系统的机器都能执行这种中间代码。Java源程序被编译成一种与机器无关的字节码格式，在Java虚拟机上运行。</p></blockquote><h3 id="多线程">多线程</h3><blockquote><p>从略</p></blockquote><p id="skip1"></p><h3 id="快速开始">快速开始</h3><p>新建文本文件，命名为<code>QuickStart.java</code>，通过创建同名的 <strong>类</strong>，并调用<code>System</code>类中的<code>out</code>的<code>println</code>方法输出内容。</p><p>程序运行接口与C类似的，是<code>main()</code>函数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QuickStart.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSrart</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="基本数据类型与运算">基本数据类型与运算</h2><blockquote><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p></blockquote><table><thead><tr><th>基本数据类型</th><th>占字节数</th><th>占位数</th><th>最小值</th><th>最大值</th><th>包装类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>boolean</code></td><td>1字节</td><td>8位</td><td></td><td></td><td>Boolean</td><td><code>false</code></td></tr><tr><td><code>byte</code></td><td>1字节</td><td>8位</td><td>-128</td><td>127</td><td>Byte</td><td><code>0</code></td></tr><tr><td><code>char</code></td><td>2字节</td><td>16位</td><td><code>\u0000</code></td><td><code>\uffff</code></td><td>Character</td><td><code>\u0000</code></td></tr><tr><td><code>short</code></td><td>2字节</td><td>16位</td><td>-2^15</td><td>2^15-1</td><td>Short</td><td><code>0</code></td></tr><tr><td><code>int</code></td><td>4字节</td><td>32位</td><td>-2^31</td><td>2^31-1</td><td>Integer</td><td><code>0</code></td></tr><tr><td><code>float</code></td><td>4字节</td><td>32位</td><td></td><td></td><td>Float</td><td><code>0.0f</code></td></tr><tr><td><code>long</code></td><td>8字节</td><td>64位</td><td>-2^63</td><td>2^63-1</td><td>Long</td><td><code>0L</code></td></tr><tr><td><code>double</code></td><td>8字节</td><td>64位</td><td></td><td></td><td>Double</td><td><code>0.0d</code></td></tr></tbody></table><ul><li>与C++不同，Java中的<strong>布尔值</strong>是<code>boolean</code>，而不是<code>bool</code>，可用<code>%b</code>或<code>%B</code>输出。</li><li>与C不同，输出时：整数都是<code>%d</code>，浮点数都是<code>%f</code>，没有<code>%lf</code>等概念。</li><li>值得注意的是，java中，<code>char</code>型数据占两个字节，编码不是ASCII码而是 <strong>Unicode码</strong>。</li></ul><h3 id="类型转换">类型转换</h3><p>数据类型的转换遵循以下规则：</p><ol><li><p>不能对<code>boolean</code>进行类型转换</p></li><li><p>不能把类型转换成<strong>其它对象类型</strong></p></li><li><p>把容量大的类型转换成容量小的类型，需通过比较 进行<strong>强制转换</strong></p></li><li><p>强制类型转换可能会<strong>损失精度</strong></p></li></ol><p>$ 注：byte &lt; char &lt; int &lt; long &lt; float &lt; double $</p><h3 id="运算符">运算符</h3><blockquote><p>以下介绍均以展现异同为主，不过多介绍</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法运算</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADD</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">3</span>+<span class="number">4</span>);<span class="comment">//结果为 7</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);<span class="comment">//结果为 97+1=98 &#x27;a&#x27;的Unicode是97</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);<span class="comment">//结果为 a1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span>+<span class="string">&quot;world!&quot;</span>);<span class="comment">//结果为 hello world!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JAVA中的加法在C的基础上扩充了许多功能，诸如字符串拼接等。（这与C++和python类似）</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取余运算</span></span><br><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>%-<span class="number">0.3</span>;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">//结果为：0.10000000000000003</span></span><br></pre></td></tr></table></figure><ul><li><p>JAVA中，取余运算符的右边可以为浮点数，而<code>/</code>则与C中一致，若两边均为整型结果取整。</p><p>但是python中，<code>/</code>默认结果是浮点数，<code>//</code>才表示整除含义</p></li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位运算符</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">9</span>;<span class="comment">// a = 11110111(二进制补码)</span></span><br><span class="line">a = a &gt;&gt; <span class="number">1</span>; </span><br><span class="line"><span class="comment">/* a右移一位:</span></span><br><span class="line"><span class="comment">	(a是负数，最高位补1) </span></span><br><span class="line"><span class="comment">	1 1111011 </span></span><br><span class="line"><span class="comment">	(开始时的最后那个1因为右移舍去)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">9</span>;</span><br><span class="line">b = b &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* b右移一位:</span></span><br><span class="line"><span class="comment">	(无论b是否为负，最左边一律补0)</span></span><br><span class="line"><span class="comment">	0 1111011</span></span><br><span class="line"><span class="comment">	(开始时的最后那个1因为右移舍去)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;&lt; 和 &lt;&lt;&lt; 同理</span></span><br></pre></td></tr></table></figure><ul><li>与C不同，C 只存在<code>&gt;&gt;</code>和<code>&lt;&lt;</code>，实际效果因编译器而异；但java运用两种形式做了统一</li></ul><br><h2 id="流程控制">流程控制</h2><blockquote><p>if语句、for循环、while循环、switch语句，break、continue、return用法……</p><p>与C一致（笑）</p><blockquote><p>待补充</p></blockquote></blockquote><h2 id="面向对象">面向对象</h2><h3 id="类的创建">类的创建</h3><p>java 和 C++与python “如出一辙”，我们通过<code>class</code>这个关键字，创建一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>&#123;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在主函数中，通过这个 类 来创建一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">GirlFriend</span> <span class="variable">jane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirlFriend</span>();</span><br><span class="line">    <span class="comment">//我们俗称的，new一个对象 QAQ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当一个对象被创建时，会对其中各种类型的成员变量<strong>自动进行初始化赋值</strong>。</li></ul><p id="nozhizheng">与C\+\+不同的最根本的原因是JAVA的语法规则。</p><p>我们知道，<code>new</code>就是在 <strong>堆</strong> 中动态的分配一个空间，以上面的例子来看，也就是相当于将堆中的这块内存的地址传给 在 <strong>栈</strong> 中 静态分配的<code>jane</code>，用C的话来说，此时<code>jane</code>就是指向这个对象的一个 <strong>指针</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GirlFriend* jane = <span class="keyword">new</span> <span class="built_in">FirlFriend</span>();</span><br><span class="line">GirlFriend* jane = (FirlFriend*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(GirlFriend));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在C++中，上述两个语句几乎等同。</span></span><br><span class="line"><span class="comment">	不过如果想要用 jane 进行操作(访问成员),需要使用：</span></span><br><span class="line"><span class="comment">	jane-&gt;height = 165;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	在java中，隐藏了指针这个概念(取消了*号)，</span></span><br><span class="line"><span class="comment">	而且用户可以直接通过如下方式操作：</span></span><br><span class="line"><span class="comment">	jane.weight = 100;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>总而言之，在java中，我们可以<strong>简单</strong>的把<code>jane</code>就理解为一个<code>GirlFriend</code>对象，并对其操作。（但实际上二者并不等同，中间通过指针操作）</p><p>理解这一点后，我们再来看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GirlFriend</span> <span class="variable">jane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>();</span><br><span class="line"><span class="type">GirlFriend</span> <span class="variable">lily</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>();</span><br><span class="line"><span class="type">GirlFriend</span> <span class="variable">robin</span> <span class="operator">=</span> jane;<span class="comment">// line1</span></span><br><span class="line"></span><br><span class="line">jane.height = <span class="number">165</span>;</span><br><span class="line">jane.weight = <span class="number">100</span>;<span class="comment">//line2</span></span><br><span class="line">lily.height = <span class="number">190</span>;</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;%d,%d,%d,%d\n&quot;</span>,jane.height,lily.height,robin.height,robin.height);</span><br><span class="line"><span class="comment">//结果为：165,190,165,100</span></span><br></pre></td></tr></table></figure><p>重点看看我们标<code>line1</code>的那一行代码，如果我们简单的理解为 “重新创建一个新对象，对象中的所有属性值都与jane对象一模一样，二者是两样东西”，那就错了。</p><p>我们发现，在<code>line2</code>中，我们对<code>jane</code>的体重进行设置，最后输出<code>robin</code>的体重，却还是和<code>jane</code>一样。</p><p>这说明，我们的好兄弟找的女朋友并不是<code>jane</code>的双胞胎，而是<code>jane</code>换了一个名字<code>robin</code>去勾搭我们的好兄弟！</p><p><code>jane</code>和<code>robin</code>这两个变量代表的，其实是同一个对象。</p><p>如果用C中指针的想法来思考，那就是这两个指针都指向同一个内容。</p><br><h3 id="访问控制符">访问控制符</h3><blockquote><p>访问控制符一定程度上可以保证程序的安全性，灵活使用可以使得类的外部不能轻易使用 <strong>私有属性和方法</strong></p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bust;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> waist;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hip;</span><br><span class="line">    <span class="keyword">protected</span> String boyfriend_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  在主函数中，不能直接访问bust、waist、hip，否则报错</span></span><br><span class="line"><span class="comment">  但 height、weight、boufriend_name可以访问</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>类的访问控制符有四种：</p></blockquote><ul><li><p><code>public</code>、<code>private</code>、<code>protected</code></p></li><li><p>默认【即不加任何修饰符<code>default</code>】</p></li></ul><p><strong>在一个类的内部，所有的成员可以相互访问,访问控制符是透明的;访问控制符是针对外部而言的</strong></p><blockquote><p>外部访问包括两种方式：</p></blockquote><ul><li>通过<strong>类名</strong>访问类内部的成员</li><li>通过<strong>类对象名</strong>访问类内部成员</li></ul><blockquote><p>这与C++是完全一致的，具体可以参考C++的学习笔记</p></blockquote><p>既然<code>protected</code>外部也可以访问，那么这与<code>public</code>有什么区别呢？</p><p>这在之后 <strong>继承</strong> 和 <strong>包</strong> 的学习中，会着重提及~</p><p>传送门：<a href="#excel">继承/包 限制表</a>、<a href="#">？？？</a></p><hr><h3 id="构造函数">构造函数</h3><p>在python的学习中，我们可以对类进行<strong>初始化</strong>操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&quot;jane&quot;</span>)</span><br></pre></td></tr></table></figure><p>简单理解，就是我们在 “主函数”中，创建一个类对象时，会有一个函数<strong>自动执行</strong>，如果需要参数，就在<code>new</code>的时候传递。</p><p>就如python中的<code>__init__()</code>函数。</p><p>当然，作为<strong>面向对象</strong>的编程语言，C++也有 构造函数 的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">show_name</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    	<span class="built_in">Person</span>();<span class="comment">//构造函数，与类同名</span></span><br><span class="line">   	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> age;</span><br><span class="line">    	string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数定义,包括构造函数</span></span><br><span class="line">Person::<span class="built_in">Person</span>(<span class="type">int</span> ipt_age,string ipt_name)&#123;</span><br><span class="line">    age = ipt_age;</span><br><span class="line">    name = ipt_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::show_name</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Person::get_age</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不难发现，C++中的许多内容，包括访问控制符都在java中得到体现，所以 构造函数也同样得到继承</li></ul><p>在Java中，构造函数同样需要和类名相同，不需传参时，也不必像python一样需要加入<code>self</code>。</p><p>继续以之前的<code>女朋友</code>为例，编写可初始化身高和体重属性的构造函数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>&#123;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bust;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> waist;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hip;</span><br><span class="line">    <span class="keyword">protected</span> String boyfriend_name;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GirlFriend</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">        height = h;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickStart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">jane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="number">165</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">lily</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="number">190</span>,<span class="number">98</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>规则总结：</p><ol><li>“构造函数”不能有 “返回值”</li><li>函数名 必须 与 类名 一致</li></ol></blockquote><p>事实上，在我们没有自己编写的构造函数之前，其实本身内部就相当于已经有一个无参数的空函数了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">GrilFriend</span><span class="params">(<span class="keyword">void</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>但是，<strong>如果我们编写了一个构造函数之后，原来的空函数被替换掉了。</strong></p><p>再一个问题，我们能否写多个不同的构造函数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">GrilFriend</span><span class="params">(<span class="keyword">void</span>)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;无参函数~~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">GrilFriend</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有一个参数的函数~~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">GrilFriend</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有两个参数的函数~~~~&quot;</span>);</span><br></pre></td></tr></table></figure><p>其实是<strong>可以的</strong>，这涉及到 <strong>函数重载</strong> 问题，事实上这是与C++一模一样的，具体可见:<a href="../../../../fromctocplus">C++快速入门</a></p><br><h3 id="this指针">this指针</h3><p>在说明this指针之前，我们先来看一段C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_i</span><span class="params">(<span class="keyword">struct</span> A* THIS)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,THIS-&gt;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">aa</span> =</span> (<span class="keyword">struct</span> A*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> A));</span><br><span class="line">    aa-&gt;i = <span class="number">5</span>;</span><br><span class="line">    show_i(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本代码中，<code>show_i()</code>函数的作用是:将数据类型为<code>struct A</code>的指针所指向的<code>i</code>成员的数值打印出来</li><li>其中我们用到了一个形参变量：<code>THIS</code>，即本质上，<code>THIS</code>是一个指针变量，从而将我们传给他的那个指针所指向的<code>i</code>找出来</li></ul><hr><p>在Java中，设计一个类模板之后，在“主函数”里创建多个示例时，其“方法成员”是存储在代码区/方法区，且只需储存一个的。就类似于上面的<code>show_i()</code>一样，只定义这一个，但是我却可以创给它不同的指针，它就给出不同的结果。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        name = j;  <span class="comment">//line3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show_name</span><span class="params">()</span>&#123;   <span class="comment">//line 1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);   <span class="comment">//line 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在“主函数”里，用不同实例如<code>aa1</code>,<code>aa2</code>来调用<code>A.show_name()</code>时，打印结果分别是<code>aa1</code>,<code>aa2</code>的不同的<code>name</code>。</p><p>那是因为，实际上在<code>line1</code>这一行中，<code>show_name()</code>的完整思路是<code>show_name(A* this)</code>，</p><p>然后<code>line2</code>里面是<code>println(&quot;name = &quot; + this-&gt;name)</code>。不过这些已经被java隐去了，程序员可以不去在意这背后的逻辑关系。</p><hr><p>但是一般的情况下中，善用<code>this-&gt;</code>是更加符合<strong>代码规范</strong>的。</p><p>就如上面的<code>println(&quot;name = &quot; + this.name)</code>一样,因此<code>line3</code>的语句也常常用下面的代码代替：<code>this.name = j;</code></p><br><blockquote><p>A:为什么<code>line2</code>的规范写法不是用<code>this-&gt;name</code>，而是<code>this.name</code> ?</p><p>Q:这在我们前面的阐述中其实已经提到过了<a href="#nozhizheng">传送门</a>，java隐去了指针的概念，所以与指针关联的两个符号:<code>*</code>和<code>-&gt;</code>也没有了。</p></blockquote><hr><p>这其实就类似于我们python中的<code>self</code>关键词。</p><p>现在我们来回看一下前面讲 “构造函数” 的时候，我们搬出来的python的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name  <span class="comment">#line4</span></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&quot;jane&quot;</span>)</span><br></pre></td></tr></table></figure><p>可见，<code>line4</code>与前面的<code>line3</code>几乎是一样的。那么我可不可以像python一样，不再用<code>j</code>传递，也用名为<code>name</code>的形参进行传递呢？</p><p>答案是：可以。</p><p>因此，我们java的构造函数也能得到类似的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">//二者并不冲突;当然，如果用 name = name就会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="关于static">关于static</h3><blockquote><p>在前面<code>女朋友</code>的例子中，我们利用指针的知识系统的阐述了<code>jane</code>和<code>robin</code>指向的是同一个对象。因此，如果对<code>jane</code>的身高进行修改，<code>robin</code>也会相应的改变（毕竟就是同一个东西）。</p></blockquote><p>事实上，也确实可以将某一个属性设置为 <strong>静态变量</strong>，可将其视为 <strong>类本身的属性</strong>，而<strong>不只是</strong>对象的属性，属于公共的。这需要用到关键词<code>static</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名：M.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d、%d\n&quot;</span>,j,k);<span class="comment">//静态能够访问静态</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,i);<span class="comment">//报错：静态不能访问非静态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        show();<span class="comment">//非静态能够访问静态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(A.i);<span class="comment">//报错</span></span><br><span class="line">        System.out.println(A.j);<span class="comment">//输出：10</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">aa2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        aa1.j = <span class="number">99</span>;</span><br><span class="line">        System.out.println(aa2.j);<span class="comment">//输出：99</span></span><br><span class="line">        A.show();<span class="comment">//不报错，输出：hello world!</span></span><br><span class="line">        A.k = <span class="number">1</span>;<span class="comment">//报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【重要】总结</strong>：</p><ol><li>多个对象可共用<strong>static</strong>属性</li><li>静态属性可以通过<strong>类名</strong>直接访问</li><li>想要访问静态属性还需该属性是<strong>非私有</strong>的(即：不被private控制符修饰)</li><li>静态方法不能访问非静态属性，但是非静态能访问静态<ul><li>解释：因为在没有创建对象的情况下，不存在非静态的属性，因此无法访问</li></ul></li><li>static不能用来修饰构造函数</li><li>静态方法不能使用<strong>this</strong>和<strong>super</strong>(super会在之后的讲解中出现)</li></ol><hr><h4 id="static的应用">static的应用</h4><p>【1】造轮子计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//计数变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;<span class="comment">//id属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;<span class="comment">//无参构造函数</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    	由于每new一个对象就会执行构造函数，</span></span><br><span class="line"><span class="comment">    	所以可以通过静态的count变量记录new的次数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;<span class="comment">//定义函数返回对象个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【2】出品限量款</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">//id属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//创建私有静态属性aa,同时aa也是一个A对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    	如果构造函数为private，</span></span><br><span class="line"><span class="comment">    	则主函数中 A aa = new A()报错</span></span><br><span class="line"><span class="comment">    	而上面之所以能new是因为private在A类内部是透明的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getOneA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	创建公用static函数使得主函数能够获得一个A对象，</span></span><br><span class="line"><span class="comment">    	而且由于aa是static，所以创建成功后有且仅指向唯一一个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">M</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//error</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">aa2</span> <span class="operator">=</span> A.aa;<span class="comment">//error</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">aa3</span> <span class="operator">=</span> A.getOneA();<span class="comment">//succeed</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">aa4</span> <span class="operator">=</span> A.getOneA();<span class="comment">//succeed</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	但是 aa3 与 aa4 指向的是同一个对象</span></span><br><span class="line"><span class="comment">        	即 aa3 == aa4</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getOneA()</code>必须是static，因为主函数无法new对象(因为构造函数是private),所以在主函数需要用类名来调用此函数</li><li>属性<code>aa</code>必须是static，否则<code>getOneA()</code>静态函数不能访问非静态成员，而且由于<code>aa</code>是static，所以创建成功后有且仅指向唯一一个，满足我们 <strong>只能创建一个对象</strong> 这样的需求</li></ul><br><h2 id="继承">继承</h2><p>之前我们的<code>女朋友</code>示例中，我们定义了许多属性，如：身高、体重、三围、男朋友的名字等等。我们发现，除了<code>男朋友的名字</code>这一项以外，其他的都是一个<code>人类</code>也都具备的属性。</p><p>事实上，为了代码的可读性和完善性，我们希望事先创建一个<code>人类</code>这样的类，然后再创建一个<code>女朋友</code>的类，然后女朋友这个类也有人类该有的一些属性。为此，继承这一要素成了必要。</p><blockquote><h4 id="简介">简介</h4><p>一个新类从<strong>已有的</strong>类那里获得其已有的属性和方法，这就叫类的继承。<br>这个新类被称为<strong>子类</strong>，也叫派生类，已有的那个类叫做<strong>父类</strong>，也叫做基类</p><h4 id="继承的好处">继承的好处</h4><ul><li>代码得到极大的重用</li><li>形成一种类的层次体系结构</li><li>为多态创造条件</li></ul></blockquote><h3 id="如何继承">如何继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	内部已经存在有 i,j了~</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>superclass表示父类，subclass表示子类。通过<code>extend</code>来实现继承</li></ul><h3 id="注意事项">注意事项</h3><ol><li><p>子类不能够继承私有(private)属性和方法</p><ul><li>事实上私有属性也被继承过来了，可以通过我们接下来的super语句进行初始化。</li><li>但是普通的逻辑上语法上是无法直接在子类里面访问的。因此继承必须慎重，否则会浪费内存</li></ul></li><li><p id="excel">继承/包 限制 表</p></li></ol><table><thead><tr><th><em>作用域</em></th><th><em>当前类</em></th><th><em>同一 package</em></th><th><em>子孙类</em></th><th><em>其他 package</em></th></tr></thead><tbody><tr><td><em>public</em></td><td><em>√</em></td><td><em>√</em></td><td><em>√</em></td><td><em>√</em></td></tr><tr><td><em>protected</em></td><td><em>√</em></td><td><em>√</em></td><td><em>√</em></td><td><strong>×</strong></td></tr><tr><td><em>friendly</em></td><td><em>√</em></td><td><em>√</em></td><td><em>×</em></td><td><strong>×</strong></td></tr><tr><td><em>private</em></td><td><em>√</em></td><td><em>×</em></td><td><em>×</em></td><td><strong>×</strong></td></tr></tbody></table><ol start="3"><li>Java只支持 <strong>单继承</strong>，不支持多继承<ul><li>C++可以通过虚继承实现多继承，而Java可以通过 <strong>接口</strong> 一定程度上解决多继承的部分需求</li></ul></li><li>子类不能继承父类的构造方法<ul><li>可以通过<code>super</code>部分解决</li></ul></li></ol><br><h3 id="子类构造函数">子类构造函数</h3><p>我们知道，构造函数可以很方便的为类成员进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">        <span class="built_in">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当有一个新的类继承上面的类之后，其本身也会继承有相应的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主函数    </span></span><br><span class="line"><span class="comment">	B bb = new B(); </span></span><br><span class="line"><span class="comment">	System.out.println(bb.i); 不会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是想要也对继承过来的属性进行初始化就得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.i = i;</span><br><span class="line">    <span class="built_in">this</span>.j = j;</span><br><span class="line">    <span class="built_in">this</span>.k = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类的属性较多，子类想要初始化属性的话，写构造函数也会十分繁琐。</p><p>在C++中，我们可以通过以下方式解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* B 的构造函数 */</span></span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">A</span>(i,j);<span class="comment">//调用A的构造函数完成i,j的初始化</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这并不能在java中适用，因此Java引出了<code>super</code>的概念，只需在初始化B的时候调用<code>super()</code>函数，就完成了“<strong>调用父类A的构造函数完成初始化</strong>”这一行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(i,j);</span><br><span class="line">    <span class="built_in">this</span>.k = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>但是，值得注意的是 ：</p><ol><li><p><strong>super必须是在父类有构造函数的前提下，在子类的构造函数中调用，且必须是第一个执行语句</strong></p></li><li><p>如果我们不在子类的构造函数中主动写 <code>super</code>语句，<strong>系统默认</strong>为其添加一个<code>super()</code>语句[super空]。</p><ul><li>如果此时父类中没有<code>无参版的构造函数</code>，程序仍然报错</li></ul></li><li><p>子类的构造函数中，<strong>能且只能使用一次</strong><code>super()</code>函数</p></li></ol><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//super();//系统默认添加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">super</span>(i);<span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.j = j;</span><br><span class="line">        <span class="built_in">super</span>(i);<span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="重写方法">重写方法</h3><p>有些时候，子类不一定要用到和父类一模一样的方法。这种时候我们可以对子类继承过来的方法进行“重写”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAA\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B中的<code>f()</code>方法和A的同返回值同形参列表，但是结果不再一样。</p><p>但是，重写也得有一定的规则限制：</p><ol><li>重写方法必须和被重写方法具有<strong>相同</strong>的方法名称、参数列表和返回类型</li><li>子类中不允许出现与父类同名同参但不同返回类型的方法，如果出现，编译时会<strong>报错</strong></li><li>覆盖方法时，不能使用比父类中被覆盖的方法<strong>更严格</strong>的访问权限(原因我们会在<strong>多态</strong>的学习中再讨论)</li></ol><table><thead><tr><th style="text-align:center">父类使用</th><th style="text-align:center">子类可用</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">public</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">public、protected</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">不被继承</td></tr></tbody></table><hr><p>事实上，重写之后，我们还可以用回A的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.f();<span class="comment">//通过super代指父类，调用父类的f()方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例展示">实例展示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//M.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getname</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getid</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show_inf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="string">&quot;information:&quot;</span>+id+<span class="string">&quot; &quot;</span>+name;</span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id,String name,<span class="type">int</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name);<span class="comment">//直接this.id = id 报错，因为父类中id是private</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show_inf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="built_in">super</span>.show_inf()+<span class="string">&quot; &quot;</span>+<span class="built_in">this</span>.score;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String inf = &quot;information:&quot;+id+&quot; &quot;+name+&quot; &quot;+this.score 报错</span></span><br><span class="line"><span class="comment">            可等效为：</span></span><br><span class="line"><span class="comment">            String inf = &quot;information:&quot;+super.getid()+&quot; &quot;+super.getname()+&quot; &quot;+score;</span></span><br><span class="line"><span class="comment">            或：</span></span><br><span class="line"><span class="comment">            String inf = &quot;information:&quot;+this.getid()+&quot; &quot;+this.getname()+&quot; &quot;+score;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">M</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">std</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">190</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        System.out.println(std.get_inf());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="多态">多态</h2><h2 id="参考资料">参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ps411F7Sn">1.java入门教程|郝斌</a></p><p><a target="_blank" rel="noopener" href="https://www.it610.com/article/1290267675339071488.htm">2.java基本数据类型字典表</a></p><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-constructor-destructor.html">3.C++类构造函数&amp;析构函数</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yirentianran/article/details/1928874">4.Java访问权限符表格|CSDN</a></p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Java自学入门|笔记实录</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://qslie.top/posts/99aebcb8/">https://qslie.top/posts/99aebcb8/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Slie</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2020-09-22</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-03-11</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80/">语言</a></div><div class="post_share"><div class="social-share" data-image="https://z3.ax1x.com/2021/04/17/c5P76I.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">打赏</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png"></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png"></a><div class="post-qr-code-desc"></div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.16/audio/coin.mp3"></audio><script defer src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8a180649/" title="贪心算法综述|Greedy Algorithm"><img class="cover" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202206121532515.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">贪心算法综述|Greedy Algorithm</div></div></a></div><div class="next-post pull-right"><a href="/posts/42f568/" title="快速幂算法与斐波那契数列"><img class="cover" src="https://pic2.zhimg.com/v2-f253eca8b4f13a8b10abc86032682278_1440w.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">快速幂算法与斐波那契数列</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/04/09/Likong.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Slie</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sliefamily"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=1hPHFQqPhpkbBVYbFjRC4q8YQ-A72EFL&amp;noverify=0" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/SlieFamily" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sliewdyinwhite@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">秘密基地被发现啦！QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%AE%80%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Java简述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%98%93%E5%AD%A6"><span class="toc-number">1.1.</span> <span class="toc-text">简单易学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98"><span class="toc-number">1.2.</span> <span class="toc-text">安全性高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.3.</span> <span class="toc-text">跨平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="toc-number">1.5.</span> <span class="toc-text">快速开始</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">基本数据类型与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.</span> <span class="toc-text">类的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">访问控制符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">4.4.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Estatic"><span class="toc-number">4.5.</span> <span class="toc-text">关于static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.5.1.</span> <span class="toc-text">static的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">5.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.0.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">5.0.2.</span> <span class="toc-text">继承的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF"><span class="toc-number">5.1.</span> <span class="toc-text">如何继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">子类构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">重写方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%95%E7%A4%BA"><span class="toc-number">5.5.</span> <span class="toc-text">实例展示</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">6.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d3d469f8/" title="Docker - 一步到位的应用部署与上线"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/docker.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Docker - 一步到位的应用部署与上线"></a><div class="content"><a class="title" href="/posts/d3d469f8/" title="Docker - 一步到位的应用部署与上线">Docker - 一步到位的应用部署与上线</a><time datetime="2024-03-05T07:11:45.000Z" title="发表于 2024-03-05 15:11:45">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1bb1ae1/" title="GFS - 谷歌的分布式文件存储系统"><img src="http://img.49you.com/20170303/58b8d6f32d651.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="GFS - 谷歌的分布式文件存储系统"></a><div class="content"><a class="title" href="/posts/c1bb1ae1/" title="GFS - 谷歌的分布式文件存储系统">GFS - 谷歌的分布式文件存储系统</a><time datetime="2024-03-05T04:04:07.000Z" title="发表于 2024-03-05 12:04:07">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f21b6bc8/" title="HuskyLab Servers 0x519 操作指南【自用】"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/husklab_bg.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="HuskyLab Servers 0x519 操作指南【自用】"></a><div class="content"><a class="title" href="/posts/f21b6bc8/" title="HuskyLab Servers 0x519 操作指南【自用】">HuskyLab Servers 0x519 操作指南【自用】</a><time datetime="2024-03-04T13:29:31.000Z" title="发表于 2024-03-04 21:29:31">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7dae821/" title="【快速入门】集群资源管理调度系统 - Slurm"><img src="https://gitee.com/sliewdy/ImageURL-slie/raw/master/imagesNoT/QQ%E5%9B%BE%E7%89%8720210414005713.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【快速入门】集群资源管理调度系统 - Slurm"></a><div class="content"><a class="title" href="/posts/f7dae821/" title="【快速入门】集群资源管理调度系统 - Slurm">【快速入门】集群资源管理调度系统 - Slurm</a><time datetime="2024-03-04T12:50:38.000Z" title="发表于 2024-03-04 20:50:38">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8cb817a9/" title="【最优化】Levenberg-Marquardt 算法"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202401051550627.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【最优化】Levenberg-Marquardt 算法"></a><div class="content"><a class="title" href="/posts/8cb817a9/" title="【最优化】Levenberg-Marquardt 算法">【最优化】Levenberg-Marquardt 算法</a><time datetime="2023-12-22T03:07:39.000Z" title="发表于 2023-12-22 11:07:39">2023-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://z3.ax1x.com/2021/04/17/c5P76I.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Slie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to Chaos World!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("/pluginsSrc/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" href="/pluginsSrc/katex/dist/katex.min.css"><script src="/pluginsSrc/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{btf.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("/pluginsSrc/mermaid/dist/mermaid.min.js").then(t)};btf.addModeChange("mermaid",t),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.qslie.top/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.qslie.top/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.textContent=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script async src="/js/diytitle.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script async src="/js/diytitle.js"></script><script data-pjax defer src="/js/fixed_comment.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/pluginsSrc/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 算法相关，编程实现 (60)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/故事/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 杂谈日志，光影记录 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/日常/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 记忆碎片，梦境显影 (36)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/机器学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💻 机器学习，数学规划 (35)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://qslie.top/tags" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4f5fd499/" alt=""><img width="48" height="48" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/20231030204417.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/4f5fd499/" alt="">Deep Neural Net | 多层感知机与神经网络入门</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="posts/4f5fd499/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/9a95977b/" alt=""><img width="48" height="48" src="math-cover.jfif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/9a95977b/" alt="">SLie的&quot;数学基础&quot;集装箱|Perhaps.Ver1.04</a><div class="blog-slider__text">好了，你已经学会1+1=2了，下面来证明一下广义黎曼猜想吧~</div><a class="blog-slider__button" href="posts/9a95977b/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4ea9ab3c/" alt=""><img width="48" height="48" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main/Auto/202202232045587.jpeg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/4ea9ab3c/" alt="">算法分析与设计 &amp; 本站算法综述</a><div class="blog-slider__text">本文罗列了常见的经典问题和算法，以及主要的算法分析方法和设计方法</div><a class="blog-slider__button" href="posts/4ea9ab3c/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/5ebaa4d9/" alt=""><img width="48" height="48" src="https://gitee.com/sliewdy/ImageURL-slie/raw/master/imagesNoT/QQ%E5%9B%BE%E7%89%8720210414005713.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/5ebaa4d9/" alt="">捣鼓程序时的各种【踩坑】【报错】全收录</a><div class="blog-slider__text">配置环境、安装库包等网上冲浪时遇见到的各式各样奇奇怪怪的Warning和Error，以及各种治标不治本或者又治标又治本的解决方案全记录（个人向）</div><a class="blog-slider__button" href="posts/5ebaa4d9/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>