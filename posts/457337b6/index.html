<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>操作系统 o((&gt;ω&lt; ))o 一呼百应 | SLie's Blog|琴弦之轮</title><meta name="author" content="Slie"><meta name="copyright" content="Slie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统的基本概念 操作系统（Operating System，OS）是控制和管理整个计算机系统硬件与软件资源，合理地组织、调度计算机的工作与资源分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统最基本的系统软件。 操作系统的特征 并发性| Concurrence 并发是指"><link rel="shortcut icon" href="/img/%E7%A3%81%E5%B8%A6.png"><link rel="canonical" href="https://qslie.top/posts/457337b6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:{limitDay:90,position:"top",messagePrev:"本文章距离上次修改已经过了",messageNext:"天，相关内容可能不再适用，请留意."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-center"},source:{justifiedGallery:{js:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js",css:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"操作系统 o((>ω< ))o 一呼百应",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-03-11 22:44:06"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/fixed_comment.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/twikoo_beautify.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/04/09/Likong.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>声影</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/films/"><i class="fa-fw fas fa-video"></i> <span>映像</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>图书</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://z3.ax1x.com/2021/04/17/c5iSpj.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="SLie's Blog|琴弦之轮"><span class="site-name">SLie's Blog|琴弦之轮</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>声影</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/films/"><i class="fa-fw fas fa-video"></i> <span>映像</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>图书</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统 o((&gt;ω&lt; ))o 一呼百应</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-17T07:28:28.000Z" title="发表于 2022-09-17 15:28:28">2022-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-11T14:44:06.469Z" title="更新于 2024-03-11 22:44:06">2024-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/">计算机科学与技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="操作系统 o((&gt;ω&lt; ))o 一呼百应"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image:url(https://z3.ax1x.com/2021/04/17/c5iSpj.jpg)"></div><article class="post-content" id="article-container"><h2 id="操作系统的基本概念">操作系统的基本概念</h2><p><strong>操作系统</strong>（Operating System，OS）是控制和管理整个计算机系统硬件与软件资源，合理地组织、调度计算机的工作与资源分配，进而为用户和其他软件提供方便接口与环境的程序集合。<strong>操作系统是计算机系统最基本的系统软件</strong>。</p><h3 id="操作系统的特征">操作系统的特征</h3><h4 id="并发性-Concurrence">并发性| Concurrence</h4><p>并发是指两个或多个事件在同一<strong>时间间隔</strong>内发生。</p><p>OS 的并发性就是指在计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。这也是在 OS 中引入进程的目的。</p><blockquote><p>应区别 同一时间间隔（并发）与同一时刻（并行）的区别</p></blockquote><h4 id="共享性-Sharing">共享性| Sharing</h4><p>OS 的共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><ol><li>为了结果不造成混淆，规定一段时间内只允许一个进程访问该资源，其他进程在此时需要访问同样的资源时只能等待，知道前一个访问资源的进程访问完并释放资源后，才能得以访问。这样的共享方式称为 <strong>互斥共享方式</strong>，这样的资源被称 <strong>临界资源</strong>。</li><li>允许一段时间内被多个进程“同时”（分时共享）的资源满足的共享方式则为 <strong>同时访问方式</strong>。</li></ol><blockquote><p>并发与共享是 OS 的两个<strong>最基本</strong>特征。<br>若系统不允许并发执行，则不存在资源共享的问题；<br>若系统没有实施有效的资源共享管理，则会影响到并发执行，甚至无法并发执行。</p></blockquote><h4 id="虚拟性-Vitual">虚拟性| Vitual</h4><p>OS 中利用多种虚拟技术（如：时分复用技术、空分复用技术）来实现把一个物理实体在逻辑上变为若干对应物的能力（如：虚拟处理器、虚拟内存、虚拟外设等）</p><h4 id="异步性-Asynchronism">异步性| Asynchronism</h4><p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p><p>异步性使 OS 运行在一种随机的环境下，可能导致进程产生与时间有关的错误。因此，OS 必须保证多次运行进程后都能获得相同的结果。</p><h3 id="操作系统的接口">操作系统的接口</h3><h4 id="命令接口">命令接口</h4><p>用户利用命令接口来组织和控制作业的执行。<br>命令接口又有两种方式：<strong>联机控制方式</strong> 和 <strong>脱机控制方式</strong>。</p><ul><li>联机命令接口 又称 <strong>交互式</strong>命令接口，适用于分时或实时系统，是“说一句话，做一件事”。</li><li>脱机命令接口 又称 <strong>批处理</strong>命令接口，适用于批处理系统，由一组作业控制命令组成，脱机用户事先给定一份作业操作说明书，连同作业交给系统后，脱机用户则不能再直接干预作业的运行。</li></ul><h4 id="程序接口">程序接口</h4><p>程序接口由一组 <strong>系统调用（也称广义指令）</strong> 组成。<br>用户通过程序接口向 OS 请求提供相应的服务，如使用各种外设、申请分配和回收内存等。</p><p>由于系统中的缓存全部由操作系统管理，所以系统调用 不提供关于系统缓存的管理，这对用户是透明的。</p><blockquote><p>图形用户界面 GUI 最终也是通过调用程序接口实现的。</p></blockquote><h3 id="操作系统发展历程">操作系统发展历程</h3><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202209171735935.jpg" alt="操作系统发展史（图源:王道）"></p><p><strong>操作系统的基本类型</strong>主要有：批处理操作系统、分时操作系统和实时操作系统。</p><ol><li>批处理：用户脱机，作业成批，多道并发，交互力差；</li><li>分时：用户同时，用户“独占”，响应及时，交互力强；</li><li>实时：可靠性强，响应及时，利用率低。</li></ol><p>注：多道批处理系统的 I/O 设备可与 CPU 并行工作，这是借助于 <strong>中断</strong>技术 实现的。</p><h3 id="操作系统运行环境">操作系统运行环境</h3><h4 id="处理器运行模式">处理器运行模式</h4><p>计算机系统中，CPU 通常执行两种不同性质的程序：OS 内核程序 与 用户自编程序。<br>二者作用不同且前者是后者的管理者，所以内核程序需要执行一些<strong>特权指令</strong>，用户程序则不被允许执行。<br>常见的特权指令有：I/O 指令、置中断指令等。</p><p>为了实现这种划分，CPU 的运行模式被分为 <strong>用户态（目态）</strong> 以及 <strong>核心态（管态）</strong>。</p><p>内核是计算机上配置的底层软件，管理着系统的各种资源。主要包括 4 方面的内容：</p><ol><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构及处理（包括：进程管理、存储器管理和设备管理）</li></ol><h4 id="中断和异常">中断和异常</h4><p><strong>中断</strong>（Interruption）也称外中断，是指来自 CPU 执行指令外部的事件。<br><strong>异常</strong>（Exception）也称内中断，来自 CPU 执行指令内部，如非法操作码、地址越界、运算溢出以及专门的<strong>陷入指令</strong>等引起的事件。<strong>异常不能屏蔽，一旦出现必须立即处理。</strong></p><p>中断和异常又有着如下分类：<br><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202209181602110.jpg" alt="内外中断的联系与区别"></p><p>自陷(Trap)是一种事先安排的“异常”事件。<br>在用户态需要通过系统调用使用内核服务时，用户程序执行”陷入指令“（又称访管指令、trap指令）使得 CPU 的使用权转交给了操作系统内核程序，这实现了 CPU状态从用户态进入核心态。如下图所示：</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202209181600948.jpg" alt="系统调用的执行过程"></p><p>在中断处理时，前三个步骤由<strong>硬件</strong>（隐指令）直接实现。<br>中断处理时，不仅要保存 PC 断点还要保存程序状态字寄存器（PSW）的内容。前者由隐指令自动保存，后者则是操作系统保存。</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/interruption.jpg" alt="中断处理过程"></p><h3 id="操作系统结构">操作系统结构</h3><h4 id="分层式架构与模块化架构">分层式架构与模块化架构</h4><h4 id="宏内核架构与微内核架构">宏内核架构与微内核架构</h4><h3 id="操作系统引导">操作系统引导</h3><h3 id="虚拟机">虚拟机</h3><h2 id="同步与互斥">同步与互斥</h2><h3 id="临界资源">临界资源</h3><p>一次仅允许一个进程使用的资源成为 <strong>临界资源</strong>。临界资源的访问必须是<strong>互斥</strong>地进行。<br>临界资源的访问过程分为 4 部分：</p><ol><li><strong>进入区</strong> 为进入临界区使用临界资源，需要在此前检查能否进入临界区；</li><li><strong>临界区</strong> 是进程访问临界资源以进行各种操作的那段代码，也被称为 临界段；</li><li><strong>退出区</strong> 将正在访问的临界区标志清除；</li><li><strong>剩余区</strong> 代码中的其余部分。</li></ol><h3 id="进程的制约">进程的制约</h3><p>进程之间存在同步与互斥的制约关系。</p><p><strong>同步</strong> 是指为完成某种任务而建立的两个或多个进程，这些进程需要在某些位置上协调工作次序而等待、传递信息，因此而产生的制约关系。<br><strong>互斥</strong> 是指当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问。</p><p>为此，同步机制应遵循以下准则：</p><ol><li><strong>空闲让进</strong>。临界区空闲时可允许一个请求进入临界区的进程立即进入。</li><li><strong>忙则等待</strong>。</li><li><strong>有限等待</strong>。对请求访问的进程应保证能在有限时间内进入临界区。</li><li><strong>让权等待</strong>。当进程不能进入临界区时，应当立即释放处理器防止进程忙等待。</li></ol><h4 id="软件实现互斥">软件实现互斥</h4><blockquote><p>由软件实现临界区互斥的基本方法中，遵循“让权等待”并且无“饥饿”现象的算法有：Peterson’s Algorithm.</p></blockquote><p>其基本思想如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">P_i</span><span class="params">()</span></span>&#123;</span><br><span class="line">	flag[i] = True; turn = j;</span><br><span class="line">	<span class="keyword">while</span>(flag[j] &amp;&amp; turn==j);</span><br><span class="line">	<span class="comment">//critical section 临界区</span></span><br><span class="line">	flag[i] = False;</span><br><span class="line">	<span class="comment">//remainder section 剩余区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P_j</span><span class="params">()</span></span>&#123;</span><br><span class="line">	flag[j] = True; turn = i;</span><br><span class="line">	<span class="keyword">while</span>(flag[i] &amp;&amp; turn==i);</span><br><span class="line">	<span class="comment">//critical section 临界区</span></span><br><span class="line">	flag[j] = False;</span><br><span class="line">	<span class="comment">//remainder section 剩余区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，一旦设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">flag[i]=True</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span> 就表示它想进入临界区，同时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">turn=j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.854em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span>，因此如果此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9694em;vertical-align:-.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2861em"><span></span></span></span></span></span></span></span></span></span> 已经在临界区中则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 就一直等待。</p><h4 id="硬件实现互斥">硬件实现互斥</h4><p>通过硬件支持实现临界区问题的方法称为低级方法，或元方法。</p><ul><li>中断屏蔽方法</li><li>硬件指令方法<ul><li><strong>TestAndSet 指令</strong></li><li><strong>Swap 指令</strong></li></ul></li></ul><p>硬件方法的优点：适用于任意数目的进程，而不管是单处理机和多处理机；简单、容易验证其正确性；<br>硬件方法的缺点：进程等待进入临界区时要耗费处理机的时间，<strong>不能让权等待</strong>。</p><h3 id="互斥锁">互斥锁</h3><p>解决临界区的制约问题，最简单的工具就是 <strong>互斥锁（mutex lock）</strong></p><p>一个进程进入临界区时应该获得锁，利用函数 <code>acquire()</code>；在退出临界区时释放锁，利用函数 <code>release()</code>。（均为不可被中断的<strong>原子操作</strong>）</p><p>每个互斥锁有一个布尔变量 <code>available</code> 表示锁是否可用。锁可用时 <code>acquire()</code> 可调用成功，且锁不再可用。逻辑正如下面的代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!available); <span class="comment">//忙等待</span></span><br><span class="line">	available = False; <span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">	available = True; <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个进程共享同一 CPU 时，就浪费了 CPU 周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p><h3 id="信号量">信号量</h3><p>信号量机制是一种功能较强的机制。可用来解决互斥与同步问题，它只能被两个标准原语 <code>wait(S),signal(S)</code> 访问。也记为“P操作”和“V操作”。通常用硬件实现。</p><p>下面给出一种<strong>整型信号量</strong>的定义。定义一个用于表示资源数目的整型量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>，从而 PV 操作可描述为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">global semaphore S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(S &lt;= <span class="number">0</span>); <span class="comment">//资源还有剩余时退出循环</span></span><br><span class="line">	S--; <span class="comment">//允许当前进程访问资源，剩余资源数-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">	S++; <span class="comment">//访问资源结束，释放资源给其他进程，剩余资源数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S\leq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8193em;vertical-align:-.136em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span></span></span></span> 时，说明此时资源真正被占用。</p><p>若将条件变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S\lt0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7224em;vertical-align:-.0391em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 为负数时其负数的绝对值还可以用于表示当前正请求访问资源的进程个数。当然，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>S</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">S=S-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span> 的操作就得提前：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">	S--;</span><br><span class="line">	<span class="keyword">while</span>(S &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">	S++;</span><br><span class="line">	<span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量实现同步">信号量实现同步</h4><p>为了协调进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 之间的<strong>同步</strong>关系，例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 进程中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> 语句需要在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 语句的变量，或者需要发生在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 之后执行才能得到正确结果，出现这种情况时，我们可以通过 PV 操作，使得在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> 语句之前必须获得资源才能进行，而这个资源的释放应该放在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 语句执行完毕之后。</p><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">//初始化信号量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A; <span class="comment">//A语句</span></span><br><span class="line">	<span class="built_in">V</span>(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">P</span>(S);</span><br><span class="line">	B; <span class="comment">//B语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量实现互斥">信号量实现互斥</h4><p>为了协调进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 之间的<strong>互斥</strong>关系，例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_1,P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 进程中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> 语句需要同时访问某资源（限额1），出现这种情况时，我们可以通过 PV 操作，使得在 执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> 语句之前必须获得资源才能进行，执行完毕之后再释放。这样在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 语句时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 只能等待，以实现互斥。</p><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">1</span>; <span class="comment">//初始化信号量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">P</span>(S);</span><br><span class="line">	A; <span class="comment">//A语句</span></span><br><span class="line">	<span class="built_in">V</span>(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">P</span>(S);</span><br><span class="line">	B; <span class="comment">//B语句</span></span><br><span class="line">	<span class="built_in">V</span>(S);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管程">管程</h3><p>当共享资源用<strong>共享数据结构</strong>表示时，资源管理程序可用对于该数据结构进行操作的一组过程来表示，如资源的请求与释放过程。把这些数据结构和过程一并归为<strong>管程</strong>。</p><p>管程的引入是为了解决临界区分散所带来的管理和控制问题。管程<strong>一次只允许一个进程进入管程</strong>内，从而既便于系统管理共享资源，又能保证互斥。</p><p>下面仅给出管程的类C伪代码，事实上不具备实际用处，只作为感性认识。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">monitor</span>&#123; <span class="comment">//管程类</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		sharesource S; <span class="comment">//共享数据 S </span></span><br><span class="line">		condition x; <span class="comment">//定义条件变量 x</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">init_code</span><span class="params">()</span></span>&#123; <span class="comment">// 初始化资源数</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;S = <span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">take_away</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(S &lt;= <span class="number">0</span>) x.<span class="built_in">wait</span>(); <span class="comment">//资源不够时阻塞等待</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">give_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">			... <span class="comment">//归还资源</span></span><br><span class="line">			<span class="keyword">if</span>(有进程等待) x.<span class="built_in">signal</span>(); <span class="comment">//唤醒阻塞的进程</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述出现的 <code>x.wait(),x.signal()</code> 称为条件变量。<br>每个条件变量保存了一个等待队列，用于记录因某个条件 <code>x</code> 而阻塞的所以进程。</p><ul><li><code>x.wait</code> 实现将进程插入 <code>x</code> 条件不足时的等待队列，并释放之，使得其他进程使用管程；</li><li><code>x.signal</code> 用于唤醒 之前阻塞，但因 <code>x</code> 条件满足后的进程。</li></ul><p>这与信号量有所不同，共同点是都能实现进程的阻塞与唤醒，不同点是条件变量没有“值”，仅实现了“排队等待”的功能。</p><h3 id="经典同步问题">经典同步问题</h3><p>如果进程之间还具有前驱后继关系，也相应需要设置复数个信号量予以实现同步关系。</p><p>在实际设置信号量时，我们应该学会区分进程与进程之间的制约关系是互斥还是同步，从而用以解决实际问题。<br>下面列举几个经典的同步问题作为分析问题和设置信号量的示例。</p><h4 id="生产者-消费者问题">生产者-消费者问题</h4><h4 id="读者-写者问题">读者-写者问题</h4><h4 id="哲学家进餐问题">哲学家进餐问题</h4><p>假设有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个哲学家，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 根筷子，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 个碗。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore bow;</span><br><span class="line">semaphore chopsticks[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    chopsticks[i] = <span class="number">1</span>;</span><br><span class="line">bow = <span class="built_in">min</span>(n<span class="number">-1</span>,m); <span class="comment">//利用碗数量限制不大于 n-1，确保不死锁</span></span><br><span class="line"></span><br><span class="line"><span class="function">CoBegin</span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(True)</span></span>&#123; <span class="comment">//哲学家 i 的进程</span></span><br><span class="line">       Thinking; <span class="comment">//思考</span></span><br><span class="line">       <span class="built_in">P</span>(bow); <span class="comment">//拿碗</span></span><br><span class="line">       <span class="built_in">P</span>(chopsticks[i]); <span class="comment">//取左筷子</span></span><br><span class="line">       <span class="built_in">P</span>(chopsticks[(i+<span class="number">1</span>)%n]); <span class="comment">//取右筷子</span></span><br><span class="line">       eating; <span class="comment">//就餐</span></span><br><span class="line">       <span class="built_in">V</span>(chopsticks[i]); <span class="comment">//取左筷子</span></span><br><span class="line">       <span class="built_in">V</span>(chopsticks[(i+<span class="number">1</span>)%n]); <span class="comment">//取右筷子</span></span><br><span class="line">       <span class="built_in">V</span>(bow); <span class="comment">//拿碗</span></span><br><span class="line">    &#125;</span><br><span class="line">CoEnd</span><br></pre></td></tr></table></figure><h4 id="吸烟者问题">吸烟者问题</h4><h4 id="关于教科书略过的叫号问题">关于教科书略过的叫号问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">customer&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(True)&#123;</span><br><span class="line">		<span class="built_in">P</span>(call);</span><br><span class="line">		<span class="keyword">if</span>(List.<span class="built_in">search</span>(i) == True)&#123;</span><br><span class="line">			进餐;</span><br><span class="line">			<span class="built_in">V</span>(empty);</span><br><span class="line">			离开;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">V</span>(call);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">windows&#123;</span><br><span class="line">	...</span><br><span class="line">	m++;</span><br><span class="line">	List.<span class="built_in">push</span>(m);</span><br><span class="line">	<span class="built_in">V</span>(call);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="死锁">死锁</h2><p>在多道程序系统中，由于多个进程并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而多个进程并发执行也将带来名为“死锁”的问题。即多个进程因竞争资源而造成的一种僵局（互相等待）。</p><h3 id="死锁产生的原因">死锁产生的原因</h3><ol><li>系统资源的竞争：系统中的不可剥夺资源，其数量不足以满足多个进程运行的需要，从而陷入争夺资源僵局；</li><li>进程推进顺序非法：请求和释放资源的顺序不当，信号量使用不当等也会引发死锁。</li><li>死锁产生的<strong>必要条件</strong></li></ol><div class="note default modern"><p>当系统出现死锁时，必然有<strong>两个或者两个以上的进程处于阻塞态</strong></p></div><h4 id="死锁的必要条件">死锁的必要条件</h4><div class="note info simple"><p>产生死锁必须同时满足以下 4 个条件，只要其中一个不成立，死锁就不会发生。</p></div><ul><li><strong>互斥条件</strong> 进程要求对所分配的资源进行排他性使用</li><li><strong>不剥夺条件</strong> 进程所获得的资源在未使用完之前不能被其他进程剥夺</li><li><strong>请求并保持条件</strong> 进程已经保持至少一个资源，但又请求其他资源，并且要请求的资源又被其他进程占用，此时本进程只能被阻塞，但对自己已获得的资源保持不放</li><li><strong>循环等待条件</strong> 存在一种进程资源的循环等待链。链中的每个进程已获得的资源同时被链中下一进程请求。</li></ul><div class="note info simple"><p>注意，循环等待条件本身并不一定导致死锁，死锁对等待环的要求更严格。<br>资源分配图含圈而系统又不一定是死锁的原因是：同类资源数大于 1.</p></div><h4 id="极端死锁情况">极端死锁情况</h4><p>系统有同类资源 m 个，供 n 个进程共享，若每个进程 i 对资源的最大需求量为 k_i，则该系统不发生死锁的条件为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>k</mi><mi>i</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n(k_i-1)+1\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em"><span style="top:-1.8723em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:-.0315em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.7804em;vertical-align:-.136em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span></span></p><h3 id="死锁的处理策略">死锁的处理策略</h3><div class="note default modern"><p>对死锁的处理有 4 种方式：忽略、检测与恢复、避免和预防。<br>每种方法对死锁的处理从宽到严，同时，系统的并发性也由大到小。<br>例如，银行家算法处于死锁避免方法，比起属于死锁预防的资源预分配法，并发性更高。</p></div><h4 id="死锁预防">死锁预防</h4><p>通过设置某些限制条件，破坏产生死锁的 4 个必要条件的一个或几个。</p><ol><li>破坏互斥条件（考虑实际运行的正确，不允破坏）</li><li>破坏不剥夺条件</li><li>破坏请求并保持条件（采用<strong>预先静态分配方法</strong>，进程运行前实现一次性全加载）</li><li>破坏循环等待条件（采用<strong>循环资源分配法</strong>）</li></ol><h4 id="死锁避免">死锁避免</h4><p>避免死锁同样是事先预防策略，但区别于死锁预防，它是在资源动态分配的过程中，防止系统进入不安全状态以避免发生死锁。这种方法所施加的限制条件较弱。</p><p>为此，我们需要在分配资源前，分析系统当前的安全性。值得注意的是，<strong>系统进入不安全状态不等于系统陷入死锁</strong>，二者是包含关系。</p><p>对于安全性检验，以及如何进行避免的算法将在下一节的<strong>银行家算法</strong>中详细阐述。</p><h4 id="死锁检测与解除">死锁检测与解除</h4><p><strong>资源分配图</strong></p><p><strong>死锁定理</strong></p><p><strong>死锁解除</strong></p><h3 id="银行家算法">银行家算法</h3><h2 id="内存管理">内存管理</h2><p>内存管理是OS设计中最重要和最复杂的内容之一。操作系统必须对内存空间进行合理的划分和有效的动态分配，提高内存的利用率。其主要功能有：</p><ol><li>内存分配与回收；</li><li>地址转换；</li><li>内存空间扩充；</li><li>内存共享；</li><li>存储保护</li></ol><h3 id="程序链接与装入">程序链接与装入</h3><p>为了将用户源程序变为可在内存中执行的程序，通常需要经过：编译、链接和装入三个步骤。</p><p><strong>编译</strong>就是由编译程序将源代码编译成若干目标模块的过程。<br><strong>链接</strong>需要完成将目标模块与其所需库函数链接形成一个完整的装入模块。<br><strong>装入</strong>则顾名思义，将装入模块装入内存执行。</p><p>程序的链接有以下三种方式：</p><ol><li>静态链接：在程序运行前直接链接，之后不再拆开，该过程实现<strong>修改相对地址</strong>和<strong>变换外部调用符号</strong>。</li><li>装入时动态链接：在装入内存时，边装入边链接，优点是<strong>便于修改和更新</strong>，便于实现目标模块的<strong>共享</strong>。</li><li>运行时动态链接：在程序执行中需要某目标模块时才进行链接，优点是加快了装入过程，节省内存空间。</li></ol><p>内存的装入有以下三种方式：</p><ol><li>绝对装入：只适用于单道程序环境，直接产生绝对地址。</li><li>可重定位装入：在装入时对目标程序地址进行修改，利用相对地址。该过程在装入时一次完成，也被称为 <strong>静态重定位</strong>。</li><li>动态运行时装入：也称<strong>动态重定位</strong>。不立即把相对地址转为绝对地址，而推迟到真正运行时才进行，该方法需要一个重定位寄存器支持。优点是可以将程序分配到不连续的存储区，根据需要动态申请分配内存，便于程序段共享。</li></ol><h3 id="连续分配管理方式">连续分配管理方式</h3><p>连续分配方式是指为一个用户程序分配一块连续的内存空间。主要包括单一连续分配、固定分区分配和动态分区分配。</p><h4 id="单一连续分配">单一连续分配</h4><p>内存在该方式下被分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分。而在用户区内存中，仅有一道用户程序。</p><p>该方式简单、<strong>无外部碎片</strong>、无须内存保护。但<strong>只能用于单用户、单任务的操作系统</strong>，<strong>有内部碎片</strong>，利用率低。</p><h4 id="固定分区分配">固定分区分配</h4><p>内存在该方式下被分为若干固定大小的区域，每个分区只装入一个作业。当分区空闲时即可从后备作业队列中选择适当大小的作业装入。是<strong>多道程序设计</strong>中最简单的分配方式。</p><p>该方式存在两个问题：一是程序太大时可能无法装入任何分区，这是就需要利用<strong>覆盖技术</strong>；二是程序太小时仍然装入某个分区中，造成空间浪费，存在<strong>内部碎片</strong>。</p><h4 id="动态分区分配">动态分区分配</h4><p>又称 可变分区分配。它在进程装入内存时，根据实际需要动态地为之分配内存，使得分区大小正好适合进程所需。</p><p>动态分区在开始时效果较好，但随着时间的推移，内存中会出现越来越多的小内存块无法被利用，产生<strong>外部碎片</strong>，从而降低利用率。可以通过<strong>紧凑技术</strong>克服，但是需要额外的动态重定位寄存器支持，并且相对耗时。</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210091521973.jpg" alt="动态分区分配"></p><p>在进程换入/装入内存是，若内存中有若干足够大的空闲区，则操作系统有如下几种算法对其进行分配：</p><ol><li>首次适应（First Fit）：空闲分区按地址从低到高排序，选择第一个足够放入的区域。</li><li>邻近适应（Next Fit）：又称循环首次适应算法，由首次适应算法演变得来，不同的是在分配内存时是从上次查找结束的位置开始继续查找。</li><li>最佳适应（Best Fit）：空闲分区按容量从小到大排序，选择第一个足够放入的区域。</li><li>最坏适应（Worst Fit）：空闲分区按容量从大到大排序，选择第一个足够放入的区域。</li></ol><div class="note default modern"><p><strong>首次适应算法</strong>是最简单，通常也是最好和最快的算法。但是会使得低地址部分出现很多闲置的小空闲区，且每次分配都要经过，增加了开销。<br><strong>邻近适应算法</strong>试图解决这个问题，但内存空间尾部也会因此分裂成小碎片，通常反而不如首次适应。<br><strong>最佳适应算法</strong>虽然名字叫“最佳”，但实际表现却是最差的，会产生<strong>最多的外部碎片</strong>。<br><strong>最坏适应算法</strong>看起来不容易产生外部碎片，但是会把大区域划分开来，会导致没有足够可用的大内存快使用，性能也非常差。</p></div><h3 id="基本分页存储管理">基本分页存储管理</h3><p>把主存空间划分为大小相等且固定的块，并且块相对较小，以此作为主存的基本单位。每个进程也以块为单位进行划分，申请内存时也以此逐个申请块空间。这样的存储管理方式称为分页管理。</p><p>由于块的大小与分区分配相比小得多，进程也以此为单位划分，所以<strong>分页管理不会产生外部碎片，进程只在最后一个不完整块申请主存块时才产生内部碎片</strong>。</p><p>每个进程平均只产生半块大小的内部碎片（也称页内碎片）。</p><h4 id="页表">页表</h4><p>进程内的块称为 页（Page），内存中的块称为页框或页帧（Page Frame），外存也以同样的单位进行划分，直接称为块或盘块（Block）。</p><p>综上所述，有：<strong>页大小=块大小=内存大小/页数</strong></p><p>进程执行时需要申请主存空间，即为每一个页分配可用的页框，这就产生了页与页框的一一对应。这个对应关系由系统为每个进程建立的页表体现。</p><h4 id="地址变换机构">地址变换机构</h4><p>分页系统的逻辑地址由 页号和页内偏移量组成。</p><p>地址变换机构的任务是将逻辑地址转换为内存中的物理地址。地址变换借助页表实现。如下图所示：</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210091559151.png" alt="分页管理的地址变换机构"></p><p>在系统中通常设置一个<strong>页表寄存器</strong>（PTR)，存放着页表在内存的起始地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">F</span></span></span></span> 和页表长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span> 。</p><ul><li>进程未执行时，页表的始址和页表长度存放在本进程的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>C</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">PCB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05017em">PCB</span></span></span></span> 中</li><li>当进程被调度执行时，才将页表始址和页表长度装入页表寄存器中</li></ul><p>设页面大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span>，逻辑地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 到物理地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span></span></span></span> 的变换过程如下（假设逻辑地址、页号、每页的长度都是<strong>十进制数</strong>）：</p><ol><li>计算页号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mspace width="1em"><mo stretchy="false">(</mo><mi>P</mi><mo>=</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P\quad(P= A/L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:1em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">A</span><span class="mord">/</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 和页内偏移量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mspace width="1em"><mo stretchy="false">(</mo><mi>W</mi><mo>=</mo><mi>A</mi><mi mathvariant="normal">%</mi><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W\quad(W=A\%L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span><span class="mspace" style="margin-right:1em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.13889em">W</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">A</span><span class="mord">%</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>。</li><li>比较页号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span> 和页表长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>≥</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">P≥M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8193em;vertical-align:-.136em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span>，则产生<strong>越界中断</strong>，否则继续执行。</li><li>页表中页号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span> 对应的<strong>页表项地址</strong>=<strong>页表始址</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">F</span></span></span></span>＋<strong>页号</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span> × <strong>页表项长度</strong>，取出该页表项内容<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">b</span></span></span></span>，即为<strong>物理块号</strong>。</li><li>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>b</mi><mo>×</mo><mi>L</mi><mo>+</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">E=b×L+W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7778em;vertical-align:-.0833em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span></span></span></span>，用得到的物理地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span></span></span></span> 去访问内存。</li></ol><div class="note info simple"><p>注意区分页表长度和页表项长度。<br>页表长度是指一共有多少页，页表项长度是指页地址占多大的存储空间。</p></div><h4 id="快表">快表</h4><p>不难得出：<strong>页式管理在存取数据或指令时至少要访问 2 次内存</strong>。第一次访问页表，第二次通过页表得到的物理地址去访问内存。<br>为了解决两次访存降低效率的问题，可在地址变换机构中增设一个 具有并行查找能力的高速缓存——<strong>快表</strong>。又称 <strong>相联存储器</strong>（TLB）。对应地，主存中的页表称为慢表。</p><p>在有快表的分页管理机制中，CPU给出逻辑地址后，由硬件进行地址转换，先将页号送入高速缓冲存储器，将页号与快表中的所有页号进行比较。<br>如果找到，就可直接拼接得到物理地址，对内存进行一次访存就能实现存取。<br>否则，访问慢表读出页表项之后，访问物理地址的同时，还将其存入快表，以便后续可能再次访问。若快表已满，则须按一定的算法淘汰一个旧的页表项。</p><p>一般快表的命中率达90%以上，其有效性基于著名的<strong>局部性原理</strong>。我们会在之后具体讨论。</p><div class="note default modern"><p>由此可看出，当快表中查找不到时，需要 <strong>一次访问高速缓存+两次访问内存</strong> 才能实现存取。而有些处理机设计为快表慢表同时查找，快表成功就终止慢表查询。<br>如果题目并没有给出该处理机可同时处理，则按前者计算。</p></div><h4 id="多级页表">多级页表</h4><p>当页数过多、页表过大时，如果要求页表同样进入内存以便查找，这同样会造成内存利用率的降低。（因为页表占用的是内存中一片连续的区域）<br>因此，为了压缩页表，我们进一步延申页表映射的思想，考虑建立页表的页表，即二级页表来实现页表的映射关系，使得页表内容也可以分散存储。如果二级页表还是很大，就建立三级页表，以此类推。</p><p>为查询方便，<strong>我们规定顶级页表最多只能占 一个页面。</strong></p><p>若页表划分为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> 级，则需要访存<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span> 次，同样地，引入快表后最少只需 1 次。</p><h3 id="基本分段存储管理">基本分段存储管理</h3><p>分页管理方式是从计算机的角度考虑设计的，目的是提高内存利用率，提升计算机性能，由硬件实现，对用户透明。<br>而分段管理方式则考虑到了用户和程序员，以满足 方便编程、信息保护与共享、动态增长及动态链接等多方面的需求。</p><p>段式管理按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，则可将其划分为5段，每段都从0开始编址并分配一段<strong>连续的地址空间</strong>。</p><blockquote><p>段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的</p></blockquote><h4 id="地址变换机构-2">地址变换机构</h4><p>分段系统的逻辑地址由段号和段内偏移量组成。</p><p>地址变换机构通过段表对其进行地址转换，其中，段表又由段号、段长和本段在主存中的始址组成。相比页表，新增了段长这个字段，这是因为其空间大小各不相同导致的。</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210091634080.png" alt="分段系统的地址变换机构"></p><p>在系统中设置了<strong>段表寄存器</strong>，用于存放段表始址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">F</span></span></span></span> 和段表长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span>。从逻辑地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 到物理地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span></span></span></span> 之间的地址变换过程如下:</p><ol><li>从逻辑地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span>中取出前几位为段号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>，后几位为段内偏移量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span></span></span></span>。</li><li>比较段号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 和段表长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span>，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>&gt;</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">S&gt;M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7224em;vertical-align:-.0391em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span>，则产生<strong>越界中断</strong>，否则继续执行。</li><li>段表中段号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 对应的<strong>段表项地址</strong>=<strong>段表始址</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">F</span></span></span></span>＋<strong>段号</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> ×<strong>段表项长度</strong>，取出该段表项的前几位得到段长<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span></span>。</li><li>若段内偏移量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>≥</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">W≥C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8193em;vertical-align:-.136em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span></span>，则产生<strong>越界中断</strong>，否则继续执行。</li><li>取出段表项中该段的始址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">b</span></span></span></span>，计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">E=b+W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7778em;vertical-align:-.0833em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span></span></span></span>，用得到的物理地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span></span></span></span> 去访问内存。</li></ol><h3 id="段页式管理">段页式管理</h3><p>分页管理提高了内存利用率，分段管理反应了程序的逻辑结构，利于段的共享与保护。于是，将二者结合起来就形成了段页式管理。</p><p>在段页式管理系统中，作业的地址空间首先被划分为若干逻辑段，每段都有自己的段号，然后每个段又被划分成若干大小固定的页。<br>根据以上逻辑，作业的<strong>逻辑地址便为 (段号, 页号, 页内偏移量)</strong>，由三部分组成。</p><p>我们<strong>规定，一个进程中段表只有一个，而页表可以有多个。</strong></p><p>在进行地址变换时，首先根据段表查页表始址，然后再通过页表找到块号，最后形成物理地址。由此可见，<strong>段页式管理需要进行三次访存</strong>。</p><h3 id="一道综合题">一道综合题</h3><p>已知系统为 32 位实地址，采用 48 位虚拟地址，页面大小为 4KB，页表项大小为 8B，每段最大为 4GB。</p><p>1）假设系统使用<strong>纯页式存储</strong>，则要采用多少级页表？页内偏移多少位？</p><p>2）假设系统采用<strong>一级页表</strong>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">TLB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> 命中率为 98%，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">TLB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> 访问时间为10ns，内存访问时间为 100ns，并假设当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>L</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">TLB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> 访问失败时才开始访问内存，问平均页面访问时间是多少？</p><p>3）若是<strong>二级页表</strong>，页面平均访问时间是多少？</p><p>4）上题中，若要满足访问时间小于 120ns，则命中率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.1944em"></span><span class="mord mathnormal">p</span></span></span></span> 至少需要为多少？</p><p>5）若系统采用<strong>段页式存储</strong>，则每用户最多可以有多少个段？段内采用几级页表？</p><hr><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210162025068.png" alt="答案解析"></p><hr><h2 id="虚拟内存管理">虚拟内存管理</h2><p>虚拟内存技术允许将一个作业分多次调入内存，其实现需要建立在离散分配的内存管理方式上。因此有如下几种方式：请求分页存储管理、请求分段存储管理、请求段页式存储管理。</p><p>无论是哪一种方式，都需要一定的硬件支持。一般包括以下几个方面：</p><ol><li>一定容量的内存和外存；</li><li>页表或段表机制，作为主要的数据结构；</li><li>中断机构，当用户程序要访问的部分未调入主存时则产生中断；</li><li>地址变换机构，逻辑地址到物理地址的变换。</li></ol><h3 id="请求分页管理方式">请求分页管理方式</h3><p>请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能、页面置换功能。</p><p><strong>请求分页是目前最常用的一种实现虚拟存储器的方法。</strong></p><h4 id="页表机制">页表机制</h4><p>为了发现和处理要访问的页面当前不在内存中的情况，在页式管理的页表项基础上新增4个字段：</p><ol><li>状态位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span>：指示该页是否已调入内存，供程序访问时参考；</li><li>访问字段<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span>：记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，供<strong>置换算法</strong>换出页面时参考；</li><li>修改位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span>：标识该页在调入内存后是否被修改，以确定页面置换时是否写回外存；</li><li>外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入时参考。</li></ol><p>最终得到请求分页系统下的页表项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[页号, 物理块号, 状态位 P, 访问字段 A, 修改位 M, 外存地址]</span><br></pre></td></tr></table></figure><h4 id="缺页中断">缺页中断</h4><p>当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺页面调入内存。</p><p>缺页中断作为中断，同样要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等步骤。但值得注意的是：</p><ol><li><strong>缺页中断属于内部异常</strong>。它在指令执行期间产生</li><li>一条指令在执行期间<strong>可能产生多次</strong>缺页中断</li></ol><h4 id="地址变换机构-3">地址变换机构</h4><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210101628235.jpg" alt="请求分页管理的地址变换流程图"></p><h3 id="页框分配">页框分配</h3><h4 id="内存分配策略">内存分配策略</h4><p>对于分页式虚拟内存，在进程准备执行时，不需要也不可能把一个进程的所有页都读入内存，因此操作系统必须决定“读多少页”，即决定给特定的进程分配多少页框。</p><p>给一个进程分配的物理页框的集合就是这个进程的<strong>驻留集</strong>。</p><p>内存分配有固定和可变分配两种策略，而页面置换又有全局和局部置换两种策略。我们可以组合得出以下三种适用策略：</p><ol><li><strong>固定分配局部置换</strong>。每个进程分配固定数目的物理块，置换时从该进程内部选择页面进行置换</li><li><strong>可变分配全局置换</strong>。先每个进程分配一定数目的物理块，在执行过程中可适当增减，发售缺页时从空闲块队列中选择</li><li><strong>可变分配局部置换</strong>。可变分配，只在内部置换。若频繁缺页则操作系统为该进程再分配物理块，直到缺页率趋于适当程度；反之，若缺页率很低亦可适当减少分配给该进程的物理块，但不能引起缺页率的明显增加。</li></ol><p>虽然第三种方法实现起来较为复杂，也需要开销，但相比其频繁的页面置换所浪费的资源，这种牺牲是值得的。</p><h4 id="物理块调入算法">物理块调入算法</h4><p>采用固定分配策略是，将系统中空闲物理块分配给各进程的算法有如下几种：</p><ol><li>平均分配算法。</li><li>按比例分配算法。</li><li>优先权分配算法。为重要和紧迫的进程分配较多的物理块，通常是将所有空闲区分成两部分，一部分按比例分配，一部分根据优先权分配。</li></ol><h4 id="调入页面的时机">调入页面的时机</h4><ol><li>预调页策略。根据局部性原理，<strong>一次调入若干相邻页比一次调入一页更高效</strong>，但若调入的一批页面大多数都不被访问又是低效的。因此需要采用<strong>以预测为基础</strong>的预调页策略，将预计在不久后便会被访问的页面预先调入内存。但事实上目前预调页的成功率仅 50%，因此<strong>这种策略主要用于进程的首次调入</strong>，由程序员指出先调入哪些页。</li><li>请求调页策略。进程在运行中需要访问的页面不在内存时则提出请求，操作系统再相应地调入页面。这种策略可以保证调入的页面一定会被访问，也容易实现，因此目前的虚拟存储器大多采用这种策略。其<strong>缺点是一次仅调入一页，增加了磁盘 I/O 的开销。</strong></li></ol><blockquote><p>预调页就是运行前的调入，请求调页就是运行期间的调入</p></blockquote><h3 id="页面置换算法">页面置换算法</h3><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生<strong>缺页中断</strong>。（属于内部异常或称内中断）</p><p>当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做<strong>页面置换算法</strong>。</p><p>好的页面置换算法应有较低的页面置换频率。常见的页面置换算法有以下四种。</p><h4 id="最佳置换算法-Optimal-OPT">最佳置换算法 (Optimal, OPT)</h4><p>最佳置换算法的核心是从当前存入物理块的页面中将以后永远不会再被访问，或者<strong>距离下一次访问所需时间最长的页面淘汰</strong>。</p><p>例如：假设系统为某进程分配了三个物理块，并考虑到有以下页面号引用串（即会依次访问这些页面）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>7</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8389em;vertical-align:-.1944em"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span></span></span></span></span></p><p>开始运行时，先将 7, 0, 1 三个页面装入内存（由于一开始三个物理块内均没有页面，所以这三次均产生缺页中断）。<br>当进程要访问页面 2 时，产生缺页中断，根据最佳置换算法，页面 7 在第18次访问才需要调入，再次被访问的时间最长，因此会将页面 7 换出，后面的过程以此类推，具体过程如下图：</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210111714693.jpg" alt="OPT置换算法示意图"></p><p>可见，最佳置换算法可以保证最低的缺页率，但是实际上，只有进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面的访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</p><blockquote><p>虽然该算法是一种理论上的算法，但是它可以用来<strong>评价其他算法</strong>。</p></blockquote><h4 id="先进先出置换算法-First-In-First-Out-FIFO">先进先出置换算法 (First In First Out, FIFO)</h4><p>先进先出置换算法的核心很简单， 即每次选择<strong>淘汰的页面是最早进入内存的页面。</strong></p><p>我们同样用上面的例子，当进程访问页面 2 时，把最早调入的页面 7 换出。之后访问页面 3 时把当前的 2,0,1 中最早进入的页面 0 换出，以此类推。具体过程如下图：</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210111743716.jpg" alt="FIFO置换算法示意图"></p><p>FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应。因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差。</strong></p><p>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象称为<strong>贝莱迪（Belay）异常</strong>。</p><blockquote><p>FIFO算法可能出现 Belady 异常，而 LRU 和 OPT 算法永远不会出现该异常。</p></blockquote><p>为了说明 Belady 异常，我们考虑以下这种情况。页面访问顺序为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">3,2,1,0,3,2,4,3,2,1,0,4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8389em;vertical-align:-.1944em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">4</span></span></span></span></span></p><p>物理块分别为 3 和 4，则 FIFO 算法表现如下：</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210111748456.jpg" alt="Belady 异常示意"></p><p>可见，增加物理块反而造成更多次的缺页。</p><h4 id="最近最久未使用置换算法-Least-Recently-Used-LRU">最近最久未使用置换算法 (Least Recently Used, LRU)</h4><p>算法思想：<strong>每次淘汰的页面是最近最久未使用的页面。</strong></p><p>实现方法：赋予每个页面对应的页表项中，用<strong>访问字段记录该页面自上次被访问以来所经历的时间</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6151em"></span><span class="mord mathnormal">t</span></span></span></span>， 当需要淘汰一个页面时，选择现有页面中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6151em"></span><span class="mord mathnormal">t</span></span></span></span> 最大的页面，即最近最久未使用。</p><blockquote><p>LRU还有另一种实现方法：在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p></blockquote><p>使用和上面同样的实例，采用LRU算法进行页面置换：</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210111848266.jpg" alt="LRU置换算法示意图"></p><p>LRU 性能较好，但<strong>需要寄存器和栈的硬件支持</strong>，LRU是堆栈类的算法。</p><p>理论上可以证明，<strong>堆栈类算法不可能出现 Belady 异常</strong>，FIFO算法基于队列实现，不是堆栈类算法。</p><h4 id="CLOCK算法-Not-Recently-Used-NRU）">CLOCK算法 (Not Recently Used, NRU）</h4><p>最佳置换算法那性能最好，但无法实现。<br>先进先出置换算法实现简单，但是算法性能差。<br>最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p><p>而<strong>时钟置换算法</strong>则是一种<strong>性能和开销均平衡</strong>的算法。又称<strong>CLOCK算法</strong>，或<strong>最近未用算法</strong>（<strong>NRU</strong>，Not Recently Used）</p><p>👉🏻 <strong>简单CLOCK算法</strong>算法思想：</p><p>为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过<strong>链接指针链接成一个循环队列</strong>，并用一个替换指针与之相联。</p><ul><li>初始时，指针依次往后移，并对访问到的帧置 <code>1</code>；</li><li>物理块填满后，若某页被访问且它在内存中时， 置<code>1</code> ，但指针不动；</li><li>当需要淘汰一个页面时，检查指针当前所指的页的访问位：<ul><li>如果是 <code>0</code>，就选择该页换出，指针后移；</li><li>如果是 <code>1</code>，暂不换出，将访问位改为 <code>0</code>，指针后移并继续检查下一个页面.</li></ul></li></ul><p>由此可见，简单的 CLOCK 算法选择一个淘汰页面<strong>最多会经过两轮扫描</strong>。</p><p>现假设页面访问顺序：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">7,0,1,2,0,3,0,4,2,3,0,3,2,1,3,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8389em;vertical-align:-.1944em"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span></span></span></span></p><p>利用 NRU 算法处理结果如下图所示：<br><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210111923457.jpg" alt="NRU 置换算法示意图"></p><p>其中，指针的移动已用黄色标注。不难发现，只有当缺页中断产生的时候指针才会发生移动。</p><h4 id="改进型CLOCK算法">改进型CLOCK算法</h4><p>当发生缺页中断时，操作系统会把未修改过的页面替换进外存，因为内存和外存中所对应的该页面的内容相同，处理时间只有一次缺页中断访问外存的时间。但是修改过的页面则还需要向外存中写入一次，再加上缺页中断的时间，相当于访问了两次外存，是上述未修改的两倍。所以避免把修改过的页面替换下去可以提高性能。</p><p>改进型的 CLCOK 算法为此除了访问位之外，还<strong>增加了修改位</strong>，加以决策是否换出、怎么换出。</p><p>由访问位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 和修改位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span> 可以组合成下面四种类型的页面：</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>M</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A=0, M=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span></span></span></span>： 表示该页最近既未被访问， 又未被修改， 是<strong>最佳淘汰页</strong>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>M</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A=0, M=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span>： 表示该页最近未被访问， 但已被修改， 并不是很好的淘汰页。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>M</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A=1, M=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span></span></span></span>： 最近已被访问， 但未被修改， 该页有可能再被访问。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>M</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A=1, M=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span>： 最近已被访问且被修改， 该页可能再被访问。</li></ol><blockquote><p>可能有人会发现第 2 类这种情况理应不会出现。因为如果一个页帧被修改，其修改位会被置<code>1</code>，同时它也被使用了，其访问位也会被置<code>1</code>。即不会出现被修改但是没有被使用的情况。</p><p>但事实上，页帧的访问位是可能会被清零，这样第 3 类经过一次清零就会变成第 2 类了。</p></blockquote><p>算法具体步骤如下：</p><ol><li>从指针的当前位置开始，扫描循环队列。寻找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>M</mi><mo>=</mo><mn>00</mn></mrow><annotation encoding="application/x-tex">AM=00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">00</span></span></span></span> 的第一类页面作为淘汰页。在第一次扫描过程中，不改变访问位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span>。</li><li>若第(1)步失败，则开始第二轮扫描，查找<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>M</mi><mo>=</mo><mn>01</mn></mrow><annotation encoding="application/x-tex">AM=01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">01</span></span></span></span> 的第二类页面，将遇到的第一个这样的页作为淘汰页。在这个扫描过程中，将所有经过的页的访问位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 置 <code>0</code>。</li><li>若第(2)步失败，指针将回到它的最初位置，并且将所有页的访问位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">A</span></span></span></span> 均置 <code>0</code>。重复第(1)步，并且如果有必要，重复第(2)步。这样一定可以找到淘汰页。</li></ol><p>改进型的 CLOCK 算法优于简单 CLOCK 算法之处在于替换时首选没有变化的页，减少了磁盘 I/O 的操作次数。但为了找到一个可置换页可能需要经过几轮的扫描，算法本身的实现也会增加部分开销。</p><h4 id="页故障的上下限">页故障的上下限</h4><p>在虚拟页式管理系统中，设驻留集大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span>，初始时所有页帧均为空。若长为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.1944em"></span><span class="mord mathnormal">p</span></span></span></span> 的引用串中具有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个不同页号 （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\gt m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span>），对 FIFO、LRU置换算法来说，此情况下发生页故障次数的上下限分别为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.1944em"></span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">n</span></span></span></span>.</p><ul><li>上限为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.1944em"></span><span class="mord mathnormal">p</span></span></span></span>，因为存在每次访问的页号当前已经被换出的情况</li><li>下限为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span>，因为无论如何安排总有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个不同的页号首次进入主存时产生的缺页</li></ul><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210120030491.png" alt="几种不同置换算法的比较"></p><h3 id="抖动与工作集">抖动与工作集</h3><h4 id="抖动的含义与原因">抖动的含义与原因</h4><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为<strong>抖动</strong>，或<strong>颠簸</strong>。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p><p>发生抖动的<strong>根本原因</strong>是，同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存。这会使得在系统中排队等待页面调进／调出的进程数目增加。显然，对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换进／换出，而几乎不能再去做任何有效的工作，从而导致发生处理机的利用率急剧下降并趋于 0 的情况。我们称此时的进程是处于<strong>抖动状态</strong>。</p><p>抖动是在进程运行中出现的严重问题，必须采取相应的措施来解决它。为此有不少学者对它进行了深入的研究，提出了许多非常有效的解决方法。由于抖动的发生与系统为进程分配物理块的多少有关，于是有人提出了关于进程<strong>工作集</strong>的概念。</p><h4 id="工作集的概念">工作集的概念</h4><p>关于工作集的理论是1968年由 Denning 提出并推广的。 Denning 认为，基于程序运行时的局部性原理得知，程序在运行期间，对页面的访问是不均匀的，在一段时间内<strong>仅局限于较少的页面</strong>，在另一段时间内，又可能仅局限于对<strong>另一些</strong>较少的页面进行访问。这些页面被称为<strong>活跃页面</strong>。<br>如果能够预知程序在某段时间间隔内要访问哪些页面，并将它们调入内存，将会大大降低缺页率，从而可显著地提高处理机的利用率。当然，我们自然是无法预知的。</p><p>我们称在某个时刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6151em"></span><span class="mord mathnormal">t</span></span></span></span> <strong>之前所访问过</strong>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord">Δ</span></span></span></span> 个页面构成的集合为工作集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span></span></span></span>。</p><p>工作集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(t,\Delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">Δ</span><span class="mclose">)</span></span></span></span> 是二元函数，即在不同时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6151em"></span><span class="mord mathnormal">t</span></span></span></span> 的工作集大小不同，所含的页面数也不同；工作集与窗口尺寸<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord">Δ</span></span></span></span> 有关，是窗口尺寸<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord">Δ</span></span></span></span> 的非降函数（nondecreasing function)，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>W</mi><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W(t,\Delta)\subseteq W(t,\Delta+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">Δ</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.13889em">W</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">Δ</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> .</p><h4 id="预防抖动的方法">预防抖动的方法</h4><p>工作集模型预防抖动的原理是：<br>让操作系统跟踪每一个进程的工作集，为之分配数目大于工作集大小的物理块。<strong>落在工作集内的页面调入驻留集，落在工作集外的页面可以从驻留集换出</strong>。若还有空闲物理块，则可以再调入另一个进程到内存中来。<strong>若所有进程的工作集之和超过可用物理块总数，则操作系统暂停一个进程</strong>，将其页面换出并把物理块分配给其他进程，由此可用防止抖动现象。</p><p><strong>当前可以利用哪几种方法来防止“抖动”？</strong></p><ul><li>采取局部置换策略</li><li>把工作集算法融入到处理机调度中</li><li>利用“L=S”准则调节缺页率</li><li>选择暂停的进程</li></ul><blockquote><p>更多相关内容参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45798993/article/details/122825207">https://blog.csdn.net/weixin_45798993/article/details/122825207</a></p></blockquote><h3 id="内存映射文件">内存映射文件</h3><p>内存映射文件(Memeory-Mapped File) 是操作系统本身内存管理的一种机制，它的思想就是将磁盘文件中的全部或部分内容与进程的虚拟地址空间的某个区域建立映射关系。</p><p>一旦映射某个文件就进程就可以直接在内存中访问这个文件，而不必对文件执行 I/O 操作，并且可以不必对文件内容进行缓存。此外，使用内存映射文件，可以使多个进程之间并发地共享该文件，实现数据共享。如一个进程在共享内存上完成了写操作，此时另一个进程在映射到该文件的虚拟地址空间上执行读操作时，便能立刻看到上一个进程写操作的结果。这使得内存映射文件成为单台机器上的多个进程之间进行通信的最有效的方法。</p><blockquote><p>更多相关内容参考：<a target="_blank" rel="noopener" href="https://javaforall.cn/149900.html">https://javaforall.cn/149900.html</a></p></blockquote><h3 id="虚拟存储器的性能">虚拟存储器的性能</h3><ul><li>虚拟存储器的最大容量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≤</span></span></span></span> 计算机地址位数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">b</span></span></span></span> 所能容纳的最大容量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>b</mi></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">2^bB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8491em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8491em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> (字节编址)</li><li>虚拟存储器的实际容量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">=\min\{</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">min</span><span class="mopen">{</span></span></span></span> 主存容量+外存容量，最大容量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">}</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mclose">}</span><span class="mord">.</span></span></span></span></li></ul><p>若某计算机采用请求分页存储管理系统，某时刻测得其各设备的利用率如下：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mo>:</mo><mn>10</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">CPU:10\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">CP</span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8056em;vertical-align:-.0556em"></span><span class="mord">10%</span></span></span></span></li><li>磁盘交换区<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>:</mo><mn>99.7</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">:99.7\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8056em;vertical-align:-.0556em"></span><span class="mord">99.7%</span></span></span></span></li><li>其他 I/O 设备<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>:</mo><mn>5</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">:5\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8056em;vertical-align:-.0556em"></span><span class="mord">5%</span></span></span></span></li></ul><p>则可以改善<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi></mrow><annotation encoding="application/x-tex">CPU</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">CP</span><span class="mord mathnormal" style="margin-right:.10903em">U</span></span></span></span> 利用率的措施有：</p><ol><li>增大内存容量。这会使得每个进程得到更多的页框，减少缺页率，以减少换入换出过程，降低磁盘交换情况，提升 CPU 利用率。</li><li>减少多道程序度数。从已知条件知当前系统正处去频繁换入换出的状况，减少主存中运行的程序可适当减少磁盘交换，提升 CPU 利用率。</li></ol><p>增大磁盘交换区容量、使用更快的磁盘交换区、使用更快速的CPU <strong>均不能</strong>改善此情况。</p><h2 id="文件管理">文件管理</h2><h3 id="文件的定义与组成">文件的定义与组成</h3><ul><li><strong>概念</strong>：文件 (file) 是以计算机硬盘为载体的存储在计算机上的信息集合。</li></ul><p>在系统运行时，计算机以进程为基本单位进行资源调度与分配；而<strong>在用户进行输入输出时，则以文件为基本单位。</strong></p><ul><li><strong>组成形式</strong>：<ul><li>数据项：数据项是文件<strong>最低级</strong>的数据组成形式，主要可分为：<strong>基本数据项</strong>（用来描述一个对象的某种属性的一个值，是数据中最小的逻辑单位)、<strong>组合数据项</strong>（由多个基本对象组成）</li><li>记录：记录是一组相关的数据项的集合，由于描述一个对象在某方面的属性。</li><li>文件：文件是创建者所定义的、具有文件名的一组相关元素的集合。</li></ul></li></ul><h3 id="文件的属性">文件的属性</h3><ul><li><strong>名称</strong>：文件名称唯一，以容易读取的形式保存</li><li><strong>标识符</strong>：文件的唯一标签，通常为数字，是对人不可读的一种内部名称</li><li><strong>类型</strong>：被支持不同类型的文件系统所使用</li><li><strong>位置</strong>：指向设备和设备上文件的指针</li><li><strong>大小</strong>：文件当前的大小(字节、字或块表示)，包含文件允许的最大值</li><li><strong>保护</strong>：对文件进行保护的访问控制信息，比如：只读、可读可写、拒绝访问等</li><li><strong>时间、日期和用户标识</strong>：文件创建、修改和上次访问的相关信息，用于保护和跟踪文件的使用</li></ul><h3 id="文件控制块-FCB">文件控制块 (FCB)</h3><p><strong>概念</strong>：文件控制块是用来存储控制文件需要的各种信息的<strong>数据结构</strong>，以实现“ <em>按名存取</em> ”。</p><p>FCB 是一个有序集合称为目录文件，一个 FCB 就是一个文件目录项。<br>创建一个新的文件，系统会分配一个 FCB 存放在文件目录中，成为目录项。</p><p><strong>特点</strong>：<strong>FCB 必须连续存放</strong></p><p>FCB 主要包括以下信息：</p><ul><li>基本信息：比如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构。</li><li>存取控制信息：文件存取的权限</li><li>使用信息： 文件建立时间、文件修改时间</li></ul><blockquote><p>注1：一个文件目录本身也被视为一个文件，称为目录文件<br>注2：UNIX 操作系统把所有设备都视为特殊的文件，控制和访问外设都相当于在访问文件</p></blockquote><h3 id="索引结点">索引结点</h3><p>文件目录通常存放在磁盘中。在查找目录时，我们通常是按存储顺序逐个查找分块存在磁盘中的FCB目录，<strong>用文件名</strong>进行一一对比。<br>也就是说，实际上在查找时我们并未利用到 FCB 中一个文件的其他描述信息，因此有些系统（如 UNIX）便采用了文件名与文件描述信息分开存储的方式以减少查找开销。其中，采用<strong>索引结点</strong>这样的数据结构，利用指针指向实际文件描述信息的位置。</p><div class="note default modern"><p>在考虑系统创建最多文件数量的问题时，只需要考虑索引结点的个数。<br>即：索引结点数量上限 = 创建文件数量的上限</p></div><h4 id="磁盘索引结点">磁盘索引结点</h4><p>磁盘索引结点是存放在磁盘上的索引结点。UNIX 中每个文件都有一个唯一的磁盘索引结点。它主要包括以下内容：</p><ul><li>文件主标识符：拥有该文件的个人或小组的标识符</li><li>文件类型：普通文件、目录文件、特别文件</li><li>文件存取权限：各类用户对该文件的存取权限</li><li>文件物理地址：每个索引结点中含有13个地址项，<code>iaddr(0)</code> 到 <code>iaddr(12)</code> . 直接或者间接的方式给出数据文件所在盘块的编号</li><li>文件长度：字节为单位</li><li>文件链接计数：本文件系统中所有指向该文件的文件名的指针计数</li><li>文件存取时间：文件最近被进程存取，修改以及索引结点最近被修改的时间</li></ul><h4 id="内存索引结点">内存索引结点</h4><p>内存索引结点则是存放在内存中的索引结点。当文件被打开时，要将磁盘索引结点的内容复制到内存中，并且还需增加部分内容，如下：</p><ul><li>索引结点编号：用于标识内存索引结点</li><li>状态：指示 <code>i</code> 结点是否被上锁或者被修改</li><li>访问计数：每当有一个进程要访问此 <code>i</code> 结点时，计数加1，访问结束减1</li><li>逻辑设备号：文件所属文件系统的逻辑设备号</li><li>链接指针：设置分别指向空闲链表和散列队列的指针</li></ul><h3 id="文件的操作">文件的操作</h3><p><strong>创建文件</strong>：<code>create</code>系统调用</p><ul><li>系统调用参数：所需要的大小空间、文件存放路径、文件名</li><li>系统调用步骤：在外存中找到文件申请的存储空间；系统调用根据文件路径找到该目录对于的目录表，插入目录项</li></ul><p><strong>删除文件</strong>：<code>delete</code>系统调用</p><ul><li>系统调用参数：文件路径、文件名</li><li>系统调用步骤：根据文件路径找到目录表；根据文件名找到目录项；回收文件占用磁盘块；删除目录项</li></ul><p><strong>读文件</strong>：<code>read</code>系统调用</p><ul><li>系统调用参数：文件名、读入多少数据；读入数据放在内存什么位置</li><li>系统调用步骤：<strong>读文件的时候已经打开文件了</strong>，所以进程只用提供文件在打开文件表中的索引号即可；操作系统读出进程指定大小的数据存到进程指定的区域</li></ul><p><strong>写文件</strong>：<code>write</code>系统调用</p><ul><li>系统调用参数：文件名、写多少数据、写到什么位置</li><li>系统调用步骤：将进程指定文件数据写到指定大小的外存中</li></ul><p><strong>打开文件</strong>：<code>open</code>系统调用</p><ul><li>系统调用参数：文件名、文件路径、打开之后对文件的操作</li><li>系统调用步骤：根据路径找到目录表；根据文件名找到目录项；根据目录项检查用户是否有操作权限；有的话操作系统会把文件的目录项复制到“<strong>打开文件表</strong>”(两种，系统文件表：系统记录所有打开的文件；进程文件表：进程记录自己打开的文件)中；用户根据编号打开文件</li></ul><p><strong>删除文件</strong>：<code>delete</code>系统调用</p><ul><li>系统调用参数：文件存放路径、文件名</li><li>系统调用步骤：从目录中找到文件名对应的目录项；回收目标文件占用的磁盘块；从目录表中删除文件对应的目录项</li></ul><p><strong>关闭文件</strong>：<code>close</code>系统调用</p><ul><li>系统调用参数：文件路径、文件名</li><li>系统调用步骤：将进程打开文件表中相应表项删除；回收分配给该文件的内存空间；系统打开文件表的计数器：<code>count-1</code>，如果<code>count==0</code>，页删除表项</li></ul><p><strong>文件重定位</strong>（文件寻址）</p><ul><li><strong>流程</strong>：按照某种文件搜索目录，将当前文件位置设为定值。并且不会读、写文件</li></ul><p><strong>截断文件</strong></p><ul><li><strong>流程</strong> ：允许文件的所有属性不变，并删除文件内容，即将其长度设为0并释放其空间</li></ul><h3 id="文件保护">文件保护</h3><p><strong>文件保护</strong>主要是为了解决对文件的读、写、执行的许可问题（即，访问权限的保护）</p><p><strong>实现方式</strong>有：口令保护、加密保护和访问控制等。</p><p>对文件的保护可从限制对文件的访问类型出发。可以加以控制的<strong>访问类型</strong>有：<br><strong>读、写、执行、添加、删除、列表清单</strong>(列出文件名和文件属性)、文件重命名、复制、编辑等（通过低层系统调用实现，保护可以只在低层提供）</p><h4 id="访问控制">访问控制</h4><p>解决访问控制最常用的方法是根据用户身份进行控制。</p><p>根据用户身份进行控制的最普通的方法就是：为每个文件和目录增加一个<strong>访问控制列表</strong>（Access-Control List，ACL）规定每个用户名及其所允许的访问类型。</p><ul><li>优点：灵活性高，可以使用复杂的访问方法</li><li>缺点：长度无法预计且可能导致复杂的空间管理</li></ul><p>为了规避这样的缺点，可以采用<strong>精简访问列表</strong>（UNIX系统）解决。精简访问列表采用如下三种用户类型：</p><ol><li>拥有者：创建文件的用户</li><li>组：一组需要共享文件且具有类似访问的用户</li><li>其他：系统内的所有其他用户</li></ol><p>此外，还有另外两种访问控制方法，分别是口令和密码。二者均是防止用户文件被他人窃取或者存取的，并没有控制用户对文件的访问类型。</p><p><strong>口令</strong>指用户请求访问时需要提供相应的口令。优点是时间和空间开销不多；缺点是口令直接存储在系统内部，不安全。<br><strong>密码</strong>是用户对文件进行加密，用户访问需要密钥解密。优点是保密性强，节省了存储空间；缺点是加密和解密需要花费一定时间。</p><div class="note default modern"><p>访问控制机制的安全性差，但灵活性较高。<br><strong>访问控制由系统实现</strong>，否则系统本身的安全性就无法保证。<br><strong>加密机制由用户实现</strong>，否则加密方式无法扩展。</p></div><h3 id="文件的逻辑结构">文件的逻辑结构</h3><p>文件的逻辑结构是从用户的角度出发看到文件的组织形式；<br>文件的物理结构(存储结构)是从实现观点出发看文件在外存上的存储形式。</p><p>按照逻辑结构可以划分成无结构文件和有结构文件两种。</p><h4 id="无结构文件-流式文件">无结构文件 (流式文件)</h4><p>无结构文件又叫做流式文件，是最简单的文件组织形式。将数据桉顺序组织、记录、积累保存，以字节(byte)为单位，是有序信息项的集合。</p><p>因为没有结构，只能通过穷举搜索的方式查找，查找非常低效率。<br>但字符流的无结构文件管理简单，用户可方便对其进行操作。所以较适用于对基本信息单位操作不多的文件，如文本文件、源程序文件等。</p><h4 id="有结构文件-记录式文件">有结构文件 (记录式文件)</h4><p>有结构文件按照记录的组成形式可以分成顺序文件、索引文件、索引顺序文件。</p><h5 id="顺序文件">顺序文件</h5><p>顺序文件的文件记录是一个接一个的顺序排列，通常是<strong>定长</strong>的。可以顺序存储或链表形式存储。</p><p>通常以下两种结构：</p><ul><li>串结构：按照记录之间的顺序排列与关键字无关，通常按存入时间的先后顺序进行排序。检索时必须从头开始顺序查找；</li><li>顺序结构：文件中的记录<strong>按照关键字来排序</strong>。检索时可采用折半查找法提高效率。</li></ul><p>顺序文件的特点是在文件中对记录批量修改，顺序文件效率较高，但是增删改查单条记录效率比较低。</p><h5 id="索引文件">索引文件</h5><p>索引文件由<strong>逻辑文件</strong>和<strong>索引表</strong>组成。</p><p>主文件的每个记录都在索引表中设置一个表项，包含指向变长记录的指针(即存放该记录的<strong>逻辑地址</strong>)和记录的长度。<strong>索引表按关键字排序，其本身也是一个定长记录的顺序文件</strong>。</p><p>如果是<strong>定长</strong>的记录索引表中只需要有索引号(按顺序排列，二分查找)和对应指向逻辑文件的指针，即可计算出第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6595em"></span><span class="mord mathnormal">i</span></span></span></span> 条记录相对于第一条记录的地址：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mi>i</mi><mo>×</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">A_i=i\times L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7429em;vertical-align:-.0833em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></span></p><p>式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span> 是记录的定长.</p><p>如果是<strong>变长</strong>的记录，索引表会有索引号(按顺序排列，二分查找)、记录长度和执行逻辑地址的指针，第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6595em"></span><span class="mord mathnormal">i</span></span></span></span> 条记录的地址是前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7429em;vertical-align:-.0833em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span>条记录地址之和+1，即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>L</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A_i=\sum_{j=0}^{i-1}L_j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:3.2254em;vertical-align:-1.4138em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em"><span style="top:-1.8723em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span></span></p><blockquote><p>如果索引表项比较大的，比如文件为 8B，索引表项就占32个字节。这样对存储空间利用率太低了。</p></blockquote><h5 id="索引顺序文件">索引顺序文件</h5><p>索引顺序文件是顺序和索引文件二者的结合。<br>将文件的所有记录分成若干组，为顺序文件建立一张索引表，在表中为每组的<strong>第一条记录建立索引项</strong>(该记录的关键字和指向该记录的指针)。这样一来查找的时候就先根据索引表找到它所对应的组，然后再在组中顺序查找。</p><p>对于含有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> 条记录的<strong>顺序文件</strong>，查找某关键字的记录平均需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord">/2</span></span></span></span> 次。<br>对于含有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span> 条记录，分为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-.1133em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9267em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:.10903em;padding-left:.833em">N</span></span><span style="top:-2.8867em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95 702c-2.7 0-7.17-2.7-13.5-8-5.8-5.3-9.5-10-9.5-14 0-2 .3-3.3 1-4 1.3-2.7 23.83-20.7 67.5-54 44.2-33.3 65.8-50.3 66.5-51 1.3-1.3 3-2 5-2 4.7 0 8.7 3.3 12 10s173 378 173 378c.7 0 35.3-71 104-213 68.7-142 137.5-285 206.5-429 69-144 104.5-217.7 106.5-221l0 0c5.3-9.3 12-14 20-14H400000v40H845.2724s-225.272 467-225.272 467-235 486-235 486c-2.7 4.7-9 7-19 7-6 0-10-1-12-3s-194-422-194-422-65 47-65 47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1133em"><span></span></span></span></span></span></span></span></span> 组，每组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-.1133em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9267em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:.10903em;padding-left:.833em">N</span></span><span style="top:-2.8867em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95 702c-2.7 0-7.17-2.7-13.5-8-5.8-5.3-9.5-10-9.5-14 0-2 .3-3.3 1-4 1.3-2.7 23.83-20.7 67.5-54 44.2-33.3 65.8-50.3 66.5-51 1.3-1.3 3-2 5-2 4.7 0 8.7 3.3 12 10s173 378 173 378c.7 0 35.3-71 104-213 68.7-142 137.5-285 206.5-429 69-144 104.5-217.7 106.5-221l0 0c5.3-9.3 12-14 20-14H400000v40H845.2724s-225.272 467-225.272 467-235 486-235 486c-2.7 4.7-9 7-19 7-6 0-10-1-12-3s-194-422-194-422-65 47-65 47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1133em"><span></span></span></span></span></span></span></span></span> 条记录的 <strong>索引顺序文件</strong>，先顺序查找索引表，平均<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>N</mi></msqrt><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sqrt N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1767em;vertical-align:-.25em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9267em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:.10903em;padding-left:.833em">N</span></span><span style="top:-2.8867em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95 702c-2.7 0-7.17-2.7-13.5-8-5.8-5.3-9.5-10-9.5-14 0-2 .3-3.3 1-4 1.3-2.7 23.83-20.7 67.5-54 44.2-33.3 65.8-50.3 66.5-51 1.3-1.3 3-2 5-2 4.7 0 8.7 3.3 12 10s173 378 173 378c.7 0 35.3-71 104-213 68.7-142 137.5-285 206.5-429 69-144 104.5-217.7 106.5-221l0 0c5.3-9.3 12-14 20-14H400000v40H845.2724s-225.272 467-225.272 467-235 486-235 486c-2.7 4.7-9 7-19 7-6 0-10-1-12-3s-194-422-194-422-65 47-65 47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1133em"><span></span></span></span></span></span><span class="mord">/2</span></span></span></span> 次，再在组内顺序查找记录，平均<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>N</mi></msqrt><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\sqrt N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1767em;vertical-align:-.25em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9267em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:.10903em;padding-left:.833em">N</span></span><span style="top:-2.8867em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95 702c-2.7 0-7.17-2.7-13.5-8-5.8-5.3-9.5-10-9.5-14 0-2 .3-3.3 1-4 1.3-2.7 23.83-20.7 67.5-54 44.2-33.3 65.8-50.3 66.5-51 1.3-1.3 3-2 5-2 4.7 0 8.7 3.3 12 10s173 378 173 378c.7 0 35.3-71 104-213 68.7-142 137.5-285 206.5-429 69-144 104.5-217.7 106.5-221l0 0c5.3-9.3 12-14 20-14H400000v40H845.2724s-225.272 467-225.272 467-235 486-235 486c-2.7 4.7-9 7-19 7-6 0-10-1-12-3s-194-422-194-422-65 47-65 47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1133em"><span></span></span></span></span></span><span class="mord">/2</span></span></span></span> 次，一共平均<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-.1133em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9267em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:.10903em;padding-left:.833em">N</span></span><span style="top:-2.8867em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95 702c-2.7 0-7.17-2.7-13.5-8-5.8-5.3-9.5-10-9.5-14 0-2 .3-3.3 1-4 1.3-2.7 23.83-20.7 67.5-54 44.2-33.3 65.8-50.3 66.5-51 1.3-1.3 3-2 5-2 4.7 0 8.7 3.3 12 10s173 378 173 378c.7 0 35.3-71 104-213 68.7-142 137.5-285 206.5-429 69-144 104.5-217.7 106.5-221l0 0c5.3-9.3 12-14 20-14H400000v40H845.2724s-225.272 467-225.272 467-235 486-235 486c-2.7 4.7-9 7-19 7-6 0-10-1-12-3s-194-422-194-422-65 47-65 47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1133em"><span></span></span></span></span></span></span></span></span> 次。</p><p>显然，相比之下索引顺序文件提高了存取速度。</p><h5 id="直接文件或散列文件-Hash-File">直接文件或散列文件(Hash File)</h5><p>给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。<br>这种映射结构不同于顺序文件或索引文件，他没有<strong>顺序的特性</strong>。</p><p>散列文件有很高的存取速度，但是<strong>会引起冲突</strong>，即不同的关键字的散列值相同。</p><h3 id="文件的物理结构">文件的物理结构</h3><p>文件的无物理结构就是<strong>研究文件的实现</strong>。即文件数据在物理存储设备上是如何分布和组织的。<br>这个问题我们要分为两个方向：一是文件的分配方式，即对磁盘非空闲块的管理；二是文件存储空间管理，即对磁盘空闲块的管理。</p><h4 id="文件分配方式">文件分配方式</h4><h5 id="连续分配">连续分配</h5><ul><li>分配方法：要求每个文件在磁盘上占有一组<strong>连续的块</strong>，磁盘地址是线性排序的。比如一个文件长<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 块，从位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">b</span></span></span></span> 开始，那么必须在磁盘上划分出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 块连续空间存储文件，且该文件占用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>b</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b,b+1,b+2,\cdots,b+n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6667em;vertical-align:-.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span> 的块。</li><li>特点：实现简单、存取速度快；文件大小不能动态增加，并且<strong>会产生外部碎片</strong>。</li></ul><h5 id="链接分配">链接分配</h5><p>链接分配采用的是离散分配方式。它消除了磁盘的外部碎片，提高了磁盘利用率。<br>可以动态为文件分配盘块，也无须事先清楚文件的大小。此外对文件的增删改查非常方便。</p><p>链接分配又分成隐式链接分配和显式链接分配。</p><p><strong>一、隐式链接</strong></p><ul><li><p>分配方式：每个文件对应一个磁盘块的链表，文件块在磁盘中以链表的方式链接。添加文件的时候会在目录项中存储指向该文件<strong>首地址</strong>的指针和<strong>尾地址</strong>的指针。写文件的时候，系统会在磁盘中找到空闲块然后将这一块插入到文件里面。</p></li><li><p>特点：增删改查比较方便，不会产生外部碎片；但是<strong>只能顺序访问文件</strong>，磁盘块中的指针会消耗空间，稳定性不好，<strong>如果指针丢失文件就会被破坏</strong></p></li></ul><p><strong>二、显式链接</strong></p><ul><li><p>分配方式：把链接文件各个物理块的指针，从每个物理块末尾提取出来，显式地存放在内存的一张链接表(<strong>文件分配表</strong> FileAllocation Table，FAT)中。FAT 是由盘块号和指向下一块的指针构成，表头：<code>(盘块号,下一块号)</code>。</p></li><li><p>以 <code>-1</code> 表示文件到达结尾。<code>-2/-3/-4</code> 等表示磁盘块空闲。</p></li><li><p>这张表存放在内存中，系统启动就调入内存。</p></li><li><p>特点：因为表在内存中，提高了查找速度，减少访问磁盘的次数。</p></li></ul><h5 id="索引分配">索引分配</h5><p>链接分配解决了外部碎片和文件大小管理的问题，但是其<strong>不支持有效的直接访问</strong>、FAT需要占用较大的内存空间。</p><p>注意到在打开文件时并不需要将完整的 FAT 调入内存，为此，索引分配提供下述分配方法：<br>把每个文件的所有盘块都存储在索引块中，在目录项中存储指向该文件索引块的指针。</p><p><strong>特点：没有外部碎片，支持直接访问文件的任意块。</strong></p><p>注意：当文件过大的时候索引块可能存储不了一个文件的所有块号，所以索引块很难解决大的文件，但是可以引入以下三种机制解决</p><ol><li><strong>链接方案</strong>：将多个索引块链接起来</li><li><strong>多层索引</strong>：第一层索引块存储第二层索引块的信息，第二层索引块存储文件信息，或者更多层。</li><li><strong>混合索引</strong>：将多种索引方式混合使用，一个索引块中可以有直接地址、一级索引块的信息、二级索引块的信息。</li></ol><h4 id="混合索引分配">混合索引分配</h4><p>为了更全面地照顾小、中、大乃至特大型文件，可采用混合索引分配。</p><p>假如每个盘块大小 4KB，盘号长 4B，设置 10 个直接地址项、1 个一级索引、1 个二级索引 和 1 个三级索引。（一个盘块可存 4K/4 = 1024 个地址）则：</p><p>对于<strong>小型文件</strong>（≤4KB×10=40KB），为了提高其访问速度，最好让它们的每个盘块地址直接放入 FCB 中。例如我们直接在索引结点中设置 10 个直接地址项。用 <code>i.addr(0),...,i.addr(9)</code> 存放。这实现了<strong>直接寻址</strong>。</p><p>对于<strong>中型文件</strong>（≤4KB×1024=4MB），可以采用单索引方式。访问时先从 FCB 中得到索引表（利用 <code>i.addr(10)</code>），再从中获得该文件的盘块地址。这实现 <strong>一次间接寻址</strong>。</p><p>对于长度大于 40KB+4MB 的文件，采用二次间接地址分配模式。用地址项 <code>i.addr(11)</code> 提供。可计算得出<strong>二级间接寻址</strong>的文件最大可达 1024×4MB=4GB 。</p><p>对于更大的文件（达 4TB 大小）则采用<strong>三级间接寻址</strong>。用地址项 <code>i.addr(12)</code> 提供。</p><p>UNIX 系统采用的就是上述分配方法，示意图如下：</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210172049081.jpg" alt="UNIX系统的inode结构"></p><h4 id="各种分配的比较">各种分配的比较</h4><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210181400752.png" alt="三种分配方式的比较"></p><h3 id="目录结构">目录结构</h3><p>目录的操作主要有：搜索、创建文件、删除文件、显示目录、修改目录</p><ol><li><strong>单级目录</strong>：查找速度慢、文件<strong>不允许重名</strong>、不便于文件共享、不适合多用户操作。</li><li><strong>两级目录</strong>：将文件目录分成主文件目录和用户文件目录。用户文件目录记录该用户的FCB信息，先被检索；主文件目录存储用户名和用户目录所在的存储位置。缺乏灵活性，不能对文件进行分类。</li><li><strong>树形目录</strong>：树形目录是两级目录进行的推广，能够实现多级文件目录。</li></ol><p>对于树形目录，用户操作的时候根据<strong>文件路径</strong>来标识想要的文件，文件路径是一个字符串，目录名和数据文件之间用 <code>/</code> 分开。<br>从根目录开始的路径叫做<strong>绝对路径</strong>；从“当前目录”出发到所找文件的路径叫做<strong>相对路径</strong>。</p><p>树形目录可以很方便的对文件进行分类，层次结构清晰，便于文件管理与保护。但是查找文件，需要按照路径名(中间可能有很多文件目录)去寻找，增加了磁盘的访问次数。</p><ol start="4"><li><strong>无环图目录</strong>：在树形结构的基础上增加了一些指向同一个节点的边，让整个目录成为了一个有向无环图。</li></ol><p>无环图目录结构如多个用户指向一个共享结点，结点对应的文件设置一个<strong>共享计数器</strong>，有新用户访问时计数器+1，当有用户需要删除文件的时候，计数器-1。文件被修改则每个用户看到的信息都是修改后的。直到计数器的值为0后才真正实现对文件的删除。</p><ul><li>特点：方便了文件的共享，但是让文件管理系统变得更加复杂。</li></ul><h3 id="文件共享">文件共享</h3><p>文件共享就是让多个用户共享使用一个文件，系统中只保存一个文件的副本，不需要每个用户都复制一份。</p><h4 id="硬链接：基于索引节点的共享方式">硬链接：基于索引节点的共享方式</h4><p>每个用户的文件目录中只设置文件名和相应的索引结点的指针。索引结点指针，指向同一个文件的索引结点，从而读取文件信息。<br>该文件的索引结点里面还应有一个链接计数器 <code>counter</code>，用来记录当前访问文件的用户目录数量。如果此时有两个用户访问，用户A想要删除共享文件，而此时用户B还在使用，用户A只能删除它目录中的关于共享文件的目录项，不能删除共享文件。</p><h4 id="软连接：利用符号链实现文件共享">软连接：利用符号链实现文件共享</h4><p>如果 用户B 想共享访问 用户A 的中的文件 F。系统会创建一个 LINK 类型的新文件，也取名叫 F，并将其写入 B 的目录下。新文件 F 中存储的只是 A 中文件 F 的<strong>文件路径</strong>。（快捷方式）</p><p>当 B 想要访问 F 且正要读取 LINK 文件时，操作系统据此找到 F 的路径名然后对其进行读，这样实现共享的方式就是<strong>符号链接</strong>。</p><p>由此可见，在符号链共享方式下，每次访问共享文件时系统都需要逐个查找目录直到找到目标文件的索引结点，这个过程会<strong>产生多次读盘，增加了启动磁盘的频率</strong>。</p><p>显然，只有文件主才拥有指向目标文件的索引结点指针，其他用户只有文件路径名。因此不会发生删除文件后留下悬空指针的情况。文件主删除共享文件后，其他用户再访问时就<strong>会访问失败</strong>，并将符号链删除。</p><div class="note default modern"><p>注意：软硬链接都是文件系统的<strong>静态共享方法</strong>。而两个进程同时对一个文件操作的共享，称为 <strong>动态共享</strong>。</p></div><h3 id="外存空闲空间管理">外存空闲空间管理</h3><h4 id="逻辑格式化">逻辑格式化</h4><p>文件存储在一个<strong>文件卷</strong>中，文件卷可以是物理盘的一部分，也可以是整个物理盘。</p><p>在一个文件卷中，文件数据信息的空间（文件区） 和 存放文件控制信息FCB的空间（目录区） 是分离的。</p><p>划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）<br>初始化：划分好目录区和文件区，建立空闲空间管理表格及存放逻辑卷信息的超级块</p><h4 id="空闲表法">空闲表法</h4><p>空闲表法是<strong>连续的分配方式</strong>，他与内存的动态分配方式相似。为文件划分一块连续的空间。系统为外存上的所有空闲区域建立一张空闲盘块表(序号，空闲盘块的第一块号，空闲盘块数)。</p><p><strong>同样可以使用首次适应，最佳适应等算法。</strong></p><h4 id="空闲链表法">空闲链表法</h4><p>空闲链表法就是根据构成链表的基本元素不同，分成空闲盘块链和空闲盘区链，对空闲区域进行管理。</p><p><strong>空闲盘块链</strong>：将磁盘上所有的空闲空间以盘块为单位拉成一条链。创建文件时，系统从链首开始依次给文件分配块。回收式，系统依次将被回收的盘块插入到空闲盘块链的末尾。<br>特点：分配与回收简单，没有碎片产生；但是分配空间的时候要产生多次重复的操作。</p><p><strong>空闲盘区链</strong>：将外存上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。每个盘区上存储指向下一个盘区的指针，和这个盘区的大小信息。当需要分配的时候会根据文件的大小和一定的算法(一般是首次适应算法)找到合适区域。当回收的时候要注意与相邻的空闲盘区合并。<br>特点：可以用作连续分配，也可以离散分配；可以一次给一个文件分配一个区域，分配效率高，且空闲盘区链较短；但分配与回收的过程比较复杂。</p><h4 id="位示图法">位示图法</h4><p>采用二进制的一位来表示一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。其中，值为 <code>1</code> 表示该盘块已被分配。<br>这样，一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6667em;vertical-align:-.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 位组成的位示图就可以表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6667em;vertical-align:-.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个盘块的使用情况。</p><p>下面我们给出一个有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 列的位示图，其盘块的具体分配方法。其中，我们规定行列数均是从 1 开始编号的，盘块号也是从 1 开始计算。请注意，这只适用于下面的计算式，如果具体题目中有所变动应当自行调整。</p><p>盘块的分配逻辑如下：</p><ol><li><strong>顺序扫描</strong>位示图，找出一个或一组值为 <code>0</code> 的二进制位。</li><li>将找出一个或一组值为 <code>0</code> 的二进制位转换成与之对应的盘块号。例如找到当前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">map[i][j]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span></span></span></span>，则其盘块号为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">b=n(i-1)+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.854em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span></li><li>修改找到的二进制位的标志为1，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>←</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">map[i][j]\leftarrow 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span></li></ol><p>盘块的回收：<br>将需要回收的盘块的盘块号转化为具体的位示图坐标，并还原标识。即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>i</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>j</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>←</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} i&amp;=(b-1)/n+1\\j&amp;=(b-1)\% n+1\\\\ &amp;map[i][j]\leftarrow0 \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em"><span style="top:-5.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">i</span></span></span><span style="top:-3.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span><span style="top:-2.41em"><span class="pstrut" style="height:3em"></span><span class="mord"></span></span><span style="top:-.91em"><span class="pstrut" style="height:3em"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em"><span style="top:-5.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">1</span></span></span><span style="top:-3.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">1</span></span></span><span style="top:-.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em"><span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="成组链接法">成组链接法</h4><p>空闲表法和空闲链表法都不适用于大型文件系统，这会使得其本身就占用过大空间。<br>而在 UNIX 系统中，对于外存空闲空间的分配，采用的是成组链接法。这种方法结合了以上两种方法的优点，又克服了他们都有的“表太长了”的缺点。</p><blockquote><p>待更</p></blockquote><h3 id="虚拟文件系统">虚拟文件系统</h3><blockquote><p>待更</p></blockquote><h3 id="分区与安装">分区与安装</h3><h2 id="I-O-管理">I/O 管理</h2><h3 id="I-O软件层次结构">I/O软件层次结构</h3><p>（1）用户层软件：实现用户交互接口，通过库函数实现系统调用<br>（2）设备独立性软件：与硬件底层无关的操作，对上层的封装操作，向上一层提供调用接口，设备保护，容错处理，设备分配与回收，数据缓冲区管理，逻辑设备与物理设备映射映射<br>（3）设备驱动程序：CPU指令相同，负责控制硬件设备，将CPU指令转成设备操作，驱动程序以独立进程的形式存在<br>（4）中断处理程序（I/O中断的应答）：IO完成后发送中断信号，执行中断处理程序，会直接操作硬件</p><h3 id="高速缓存与缓冲区">高速缓存与缓冲区</h3><p>在块设备输入时，假设一块磁盘数据写入缓冲区的时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span></span></span></span>，操作系统将该缓冲区的数据传送到用户区的时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span>，CPU 对数据进行处理的时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span></span> ，则：</p><ul><li>单缓冲：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>+</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\max(C,T)+M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span></span></span></span></li><li>双缓冲：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>C</mi><mo>+</mo><mi>M</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(C+M,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="SPOOLing-技术">SPOOLing 技术</h3><p>利用外存/磁盘存储区域，将独占设备共享</p><h2 id="磁盘和固态硬盘">磁盘和固态硬盘</h2><h3 id="磁盘调度算法">磁盘调度算法</h3><p>一次磁盘读写操作由寻道时间、旋转延迟时间和传输时间决定。</p><ul><li><strong>寻道时间</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>+</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">T_s=m\times n+s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6667em;vertical-align:-.0833em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6667em;vertical-align:-.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">s</span></span></span></span>.<ul><li>活动头磁盘在读写信息前，将磁头移动到指定磁道所需的时间。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 是磁盘驱动器速度有关的常数，约为 0.2ms；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">s</span></span></span></span> 是磁臂的启动时间， 约为 2ms；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 是所需跨越的磁道数。</li></ul></li><li><strong>旋转延迟时间</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>r</mi></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi>r</mi></mrow><annotation encoding="application/x-tex">T_r=1/2r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1/2</span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span><ul><li>磁头定位到某一磁道的扇区所需要的时间。设磁盘的旋转速度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span>。</li></ul></li><li><strong>传输时间</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>r</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">T_t=b/rN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2806em"><span style="top:-2.55em;margin-left:-.1389em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span><ul><li>从磁盘读出或写入数据所经历的时间，取决于每次读写的字节数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">b</span></span></span></span>、磁盘每秒转数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span> 和每一个磁道上的字节数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>。</li></ul></li></ul><h4 id="FCFS-先来先服务">FCFS 先来先服务</h4><h4 id="SSTF-最短寻道时间优先">SSTF 最短寻道时间优先</h4><h4 id="SCAN-扫描-电梯调度">SCAN 扫描/电梯调度</h4><p>LOOK改进</p><h4 id="CSCAN-循环扫描算法">CSCAN 循环扫描算法</h4><p>CLOOK改进</p><h3 id="物理与逻辑初始化">物理与逻辑初始化</h3><p>一个新的磁盘是一个空白板，必须分成扇区以便磁盘控制器能读写，这个过程称为<strong>低级格式化</strong>，也叫<strong>物理格式化</strong>。</p><p>物理格式化为每个磁盘的每个扇区采用特别的数据结构，包括校验码。</p><p>为了使用磁盘存储文件，操作系统还需要将其数据结构记录在磁盘上，这个过程分为两步：</p><ol><li>将磁盘分为一个或多个柱面组成的分区，每个分区可作为一个独立的磁盘</li><li>操作系统将初始文件系统数据结构存储到磁盘上，这些数据结构包括空闲和已分配的空间及一个初始为空的目录。这个是逻辑初始化。</li></ol></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>操作系统 o((&gt;ω&lt; ))o 一呼百应</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://qslie.top/posts/457337b6/">https://qslie.top/posts/457337b6/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Slie</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-09-17</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-03-11</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://z3.ax1x.com/2021/04/17/c5iSpj.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">打赏</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png"></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png"></a><div class="post-qr-code-desc"></div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.16/audio/coin.mp3"></audio><script defer src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/de38875/" title="从决策树到集成学习与随机森林"><img class="cover" src="https://z3.ax1x.com/2021/04/17/c5P76I.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">从决策树到集成学习与随机森林</div></div></a></div><div class="next-post pull-right"><a href="/posts/64ae3e0/" title="明知结局，心固不安|2022.09"><img class="cover" src="https://z3.ax1x.com/2021/04/17/c5iSpj.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">明知结局，心固不安|2022.09</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/04/09/Likong.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Slie</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sliefamily"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=1hPHFQqPhpkbBVYbFjRC4q8YQ-A72EFL&amp;noverify=0" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/SlieFamily" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sliewdyinwhite@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">秘密基地被发现啦！QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">操作系统的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7-Concurrence"><span class="toc-number">1.1.1.</span> <span class="toc-text">并发性| Concurrence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%80%A7-Sharing"><span class="toc-number">1.1.2.</span> <span class="toc-text">共享性| Sharing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%80%A7-Vitual"><span class="toc-number">1.1.3.</span> <span class="toc-text">虚拟性| Vitual</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%80%A7-Asynchronism"><span class="toc-number">1.1.4.</span> <span class="toc-text">异步性| Asynchronism</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">命令接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">程序接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统发展历程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">处理器运行模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.2.</span> <span class="toc-text">中断和异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9E%B6%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">分层式架构与模块化架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">宏内核架构与微内核架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="toc-number">1.6.</span> <span class="toc-text">操作系统引导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.7.</span> <span class="toc-text">虚拟机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">2.</span> <span class="toc-text">同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">2.1.</span> <span class="toc-text">临界资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%B6%E7%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">进程的制约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">软件实现互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">硬件实现互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.1.</span> <span class="toc-text">信号量实现同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">2.4.2.</span> <span class="toc-text">信号量实现互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.</span> <span class="toc-text">经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.1.</span> <span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.2.</span> <span class="toc-text">读者-写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.3.</span> <span class="toc-text">哲学家进餐问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.4.</span> <span class="toc-text">吸烟者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%99%E7%A7%91%E4%B9%A6%E7%95%A5%E8%BF%87%E7%9A%84%E5%8F%AB%E5%8F%B7%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.5.</span> <span class="toc-text">关于教科书略过的叫号问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.1.</span> <span class="toc-text">死锁产生的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">死锁的必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%81%E7%AB%AF%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5"><span class="toc-number">3.1.2.</span> <span class="toc-text">极端死锁情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.</span> <span class="toc-text">死锁的处理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">3.2.1.</span> <span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">死锁避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">3.2.3.</span> <span class="toc-text">死锁检测与解除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">银行家算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5"><span class="toc-number">4.1.</span> <span class="toc-text">程序链接与装入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.2.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.2.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.2.3.</span> <span class="toc-text">动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">基本分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">快表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.3.4.</span> <span class="toc-text">多级页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">基本分段存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-2"><span class="toc-number">4.4.1.</span> <span class="toc-text">地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">段页式管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E7%BB%BC%E5%90%88%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">一道综合题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.1.</span> <span class="toc-text">页表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">5.1.2.</span> <span class="toc-text">缺页中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-3"><span class="toc-number">5.1.3.</span> <span class="toc-text">地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D"><span class="toc-number">5.2.</span> <span class="toc-text">页框分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.1.</span> <span class="toc-text">内存分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9D%97%E8%B0%83%E5%85%A5%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">物理块调入算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">5.2.3.</span> <span class="toc-text">调入页面的时机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-Optimal-OPT"><span class="toc-number">5.3.1.</span> <span class="toc-text">最佳置换算法 (Optimal, OPT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-First-In-First-Out-FIFO"><span class="toc-number">5.3.2.</span> <span class="toc-text">先进先出置换算法 (First In First Out, FIFO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-Least-Recently-Used-LRU"><span class="toc-number">5.3.3.</span> <span class="toc-text">最近最久未使用置换算法 (Least Recently Used, LRU)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLOCK%E7%AE%97%E6%B3%95-Not-Recently-Used-NRU%EF%BC%89"><span class="toc-number">5.3.4.</span> <span class="toc-text">CLOCK算法 (Not Recently Used, NRU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8BCLOCK%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.5.</span> <span class="toc-text">改进型CLOCK算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E6%95%85%E9%9A%9C%E7%9A%84%E4%B8%8A%E4%B8%8B%E9%99%90"><span class="toc-number">5.3.6.</span> <span class="toc-text">页故障的上下限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">5.4.</span> <span class="toc-text">抖动与工作集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E7%9A%84%E5%90%AB%E4%B9%89%E4%B8%8E%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.4.1.</span> <span class="toc-text">抖动的含义与原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.4.2.</span> <span class="toc-text">工作集的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%8A%96%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.3.</span> <span class="toc-text">预防抖动的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">5.5.</span> <span class="toc-text">内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">5.6.</span> <span class="toc-text">虚拟存储器的性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%BB%84%E6%88%90"><span class="toc-number">6.1.</span> <span class="toc-text">文件的定义与组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">文件的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97-FCB"><span class="toc-number">6.3.</span> <span class="toc-text">文件控制块 (FCB)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="toc-number">6.4.</span> <span class="toc-text">索引结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="toc-number">6.4.1.</span> <span class="toc-text">磁盘索引结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="toc-number">6.4.2.</span> <span class="toc-text">内存索引结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.5.</span> <span class="toc-text">文件的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">6.6.</span> <span class="toc-text">文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">6.6.1.</span> <span class="toc-text">访问控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">6.7.</span> <span class="toc-text">文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6-%E6%B5%81%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="toc-number">6.7.1.</span> <span class="toc-text">无结构文件 (流式文件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6-%E8%AE%B0%E5%BD%95%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="toc-number">6.7.2.</span> <span class="toc-text">有结构文件 (记录式文件)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">6.7.2.1.</span> <span class="toc-text">顺序文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">6.7.2.2.</span> <span class="toc-text">索引文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">6.7.2.3.</span> <span class="toc-text">索引顺序文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6%E6%88%96%E6%95%A3%E5%88%97%E6%96%87%E4%BB%B6-Hash-File"><span class="toc-number">6.7.2.4.</span> <span class="toc-text">直接文件或散列文件(Hash File)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">6.8.</span> <span class="toc-text">文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">6.8.1.</span> <span class="toc-text">文件分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">6.8.1.1.</span> <span class="toc-text">连续分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-number">6.8.1.2.</span> <span class="toc-text">链接分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">6.8.1.3.</span> <span class="toc-text">索引分配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">6.8.2.</span> <span class="toc-text">混合索引分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%88%86%E9%85%8D%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">6.8.3.</span> <span class="toc-text">各种分配的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">6.9.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">6.10.</span> <span class="toc-text">文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">6.10.1.</span> <span class="toc-text">硬链接：基于索引节点的共享方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E8%BF%9E%E6%8E%A5%EF%BC%9A%E5%88%A9%E7%94%A8%E7%AC%A6%E5%8F%B7%E9%93%BE%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">6.10.2.</span> <span class="toc-text">软连接：利用符号链实现文件共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E5%AD%98%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">6.11.</span> <span class="toc-text">外存空闲空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">6.11.1.</span> <span class="toc-text">逻辑格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-number">6.11.2.</span> <span class="toc-text">空闲表法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">6.11.3.</span> <span class="toc-text">空闲链表法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95"><span class="toc-number">6.11.4.</span> <span class="toc-text">位示图法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">6.11.5.</span> <span class="toc-text">成组链接法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.12.</span> <span class="toc-text">虚拟文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-number">6.13.</span> <span class="toc-text">分区与安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">I&#x2F;O 管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">I&#x2F;O软件层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.2.</span> <span class="toc-text">高速缓存与缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPOOLing-%E6%8A%80%E6%9C%AF"><span class="toc-number">7.3.</span> <span class="toc-text">SPOOLing 技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">8.</span> <span class="toc-text">磁盘和固态硬盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FCFS-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="toc-number">8.1.1.</span> <span class="toc-text">FCFS 先来先服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSTF-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">8.1.2.</span> <span class="toc-text">SSTF 最短寻道时间优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCAN-%E6%89%AB%E6%8F%8F-%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6"><span class="toc-number">8.1.3.</span> <span class="toc-text">SCAN 扫描&#x2F;电梯调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSCAN-%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95"><span class="toc-number">8.1.4.</span> <span class="toc-text">CSCAN 循环扫描算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E4%B8%8E%E9%80%BB%E8%BE%91%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.2.</span> <span class="toc-text">物理与逻辑初始化</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d3d469f8/" title="Docker - 一步到位的应用部署与上线"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/docker.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Docker - 一步到位的应用部署与上线"></a><div class="content"><a class="title" href="/posts/d3d469f8/" title="Docker - 一步到位的应用部署与上线">Docker - 一步到位的应用部署与上线</a><time datetime="2024-03-05T07:11:45.000Z" title="发表于 2024-03-05 15:11:45">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1bb1ae1/" title="GFS - 谷歌的分布式文件存储系统"><img src="http://img.49you.com/20170303/58b8d6f32d651.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="GFS - 谷歌的分布式文件存储系统"></a><div class="content"><a class="title" href="/posts/c1bb1ae1/" title="GFS - 谷歌的分布式文件存储系统">GFS - 谷歌的分布式文件存储系统</a><time datetime="2024-03-05T04:04:07.000Z" title="发表于 2024-03-05 12:04:07">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f21b6bc8/" title="HuskyLab Servers 0x519 操作指南【自用】"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/husklab_bg.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="HuskyLab Servers 0x519 操作指南【自用】"></a><div class="content"><a class="title" href="/posts/f21b6bc8/" title="HuskyLab Servers 0x519 操作指南【自用】">HuskyLab Servers 0x519 操作指南【自用】</a><time datetime="2024-03-04T13:29:31.000Z" title="发表于 2024-03-04 21:29:31">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7dae821/" title="【快速入门】集群资源管理调度系统 - Slurm"><img src="https://gitee.com/sliewdy/ImageURL-slie/raw/master/imagesNoT/QQ%E5%9B%BE%E7%89%8720210414005713.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【快速入门】集群资源管理调度系统 - Slurm"></a><div class="content"><a class="title" href="/posts/f7dae821/" title="【快速入门】集群资源管理调度系统 - Slurm">【快速入门】集群资源管理调度系统 - Slurm</a><time datetime="2024-03-04T12:50:38.000Z" title="发表于 2024-03-04 20:50:38">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8cb817a9/" title="【最优化】Levenberg-Marquardt 算法"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202401051550627.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【最优化】Levenberg-Marquardt 算法"></a><div class="content"><a class="title" href="/posts/8cb817a9/" title="【最优化】Levenberg-Marquardt 算法">【最优化】Levenberg-Marquardt 算法</a><time datetime="2023-12-22T03:07:39.000Z" title="发表于 2023-12-22 11:07:39">2023-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://z3.ax1x.com/2021/04/17/c5iSpj.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Slie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to Chaos World!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("/pluginsSrc/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" href="/pluginsSrc/katex/dist/katex.min.css"><script src="/pluginsSrc/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{btf.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("/pluginsSrc/mermaid/dist/mermaid.min.js").then(t)};btf.addModeChange("mermaid",t),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.qslie.top/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.qslie.top/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.textContent=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script async src="/js/diytitle.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script async src="/js/diytitle.js"></script><script data-pjax defer src="/js/fixed_comment.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/pluginsSrc/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 算法相关，编程实现 (60)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/故事/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 杂谈日志，光影记录 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/日常/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 记忆碎片，梦境显影 (36)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/机器学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💻 机器学习，数学规划 (35)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://qslie.top/tags" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4f5fd499/" alt=""><img width="48" height="48" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/20231030204417.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/4f5fd499/" alt="">Deep Neural Net | 多层感知机与神经网络入门</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="posts/4f5fd499/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/9a95977b/" alt=""><img width="48" height="48" src="math-cover.jfif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/9a95977b/" alt="">SLie的&quot;数学基础&quot;集装箱|Perhaps.Ver1.04</a><div class="blog-slider__text">好了，你已经学会1+1=2了，下面来证明一下广义黎曼猜想吧~</div><a class="blog-slider__button" href="posts/9a95977b/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4ea9ab3c/" alt=""><img width="48" height="48" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main/Auto/202202232045587.jpeg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/4ea9ab3c/" alt="">算法分析与设计 &amp; 本站算法综述</a><div class="blog-slider__text">本文罗列了常见的经典问题和算法，以及主要的算法分析方法和设计方法</div><a class="blog-slider__button" href="posts/4ea9ab3c/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/5ebaa4d9/" alt=""><img width="48" height="48" src="https://gitee.com/sliewdy/ImageURL-slie/raw/master/imagesNoT/QQ%E5%9B%BE%E7%89%8720210414005713.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/5ebaa4d9/" alt="">捣鼓程序时的各种【踩坑】【报错】全收录</a><div class="blog-slider__text">配置环境、安装库包等网上冲浪时遇见到的各式各样奇奇怪怪的Warning和Error，以及各种治标不治本或者又治标又治本的解决方案全记录（个人向）</div><a class="blog-slider__button" href="posts/5ebaa4d9/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>