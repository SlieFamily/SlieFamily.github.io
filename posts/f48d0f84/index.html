<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>堆栈与队列及其应用|数据结构Ⅱ | SLie's Blog|琴弦之轮</title><meta name="author" content="Slie"><meta name="copyright" content="Slie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="堆栈 栈的基本概念 栈（Stack）是只允许在一端进行插入或删除操作的线性表。    栈顶（Top）：线性表允许进行插入和删除的一端。   栈底（Bottom）：固定的，不允许进行插入和删除的另一端。   空栈：不含任何元素的空表。   假设某个栈 S&amp;#x3D;(a1,a2,⋯ ,an)S&amp;#x3D;(a_1,a_2"><link rel="shortcut icon" href="/img/%E7%A3%81%E5%B8%A6.png"><link rel="canonical" href="https://qslie.top/posts/f48d0f84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:{limitDay:90,position:"top",messagePrev:"本文章距离上次修改已经过了",messageNext:"天，相关内容可能不再适用，请留意."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-center"},source:{justifiedGallery:{js:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js",css:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"堆栈与队列及其应用|数据结构Ⅱ",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-03-11 22:44:06"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/fixed_comment.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/twikoo_beautify.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/04/09/Likong.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>声影</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/films/"><i class="fa-fw fas fa-video"></i> <span>映像</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>图书</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://z3.ax1x.com/2021/04/17/c5P76I.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="SLie's Blog|琴弦之轮"><span class="site-name">SLie's Blog|琴弦之轮</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>声影</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/films/"><i class="fa-fw fas fa-video"></i> <span>映像</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>图书</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">堆栈与队列及其应用|数据结构Ⅱ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-08T06:38:38.000Z" title="发表于 2021-12-08 14:38:38">2021-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-11T14:44:06.533Z" title="更新于 2024-03-11 22:44:06">2024-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/">计算机科学与技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="堆栈与队列及其应用|数据结构Ⅱ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image:url(https://z3.ax1x.com/2021/04/17/c5P76I.jpg)"></div><article class="post-content" id="article-container"><h1>堆栈</h1><h2 id="栈的基本概念">栈的基本概念</h2><p>栈（<em>Stack</em>）是只允许在一端进行插入或删除操作的<strong>线性表</strong>。</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202210311400767.png" alt="Stack"></p><ul><li><p>栈顶（<em>Top</em>）：线性表允许进行插入和删除的一端。</p></li><li><p>栈底（<em>Bottom</em>）：固定的，不允许进行插入和删除的另一端。</p></li><li><p>空栈：不含任何元素的空表。</p></li></ul><p>假设某个栈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=(a_1,a_2,\cdots,a_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 如上图所示。<br>则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 为栈底元素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 为栈顶元素。由于栈只能在栈顶进行插入和删除操作，故<strong>进栈次序</strong>依次为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,\cdots,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.1944em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>； 而<strong>出栈次序</strong>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_n,\cdots,a_2,a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.1944em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。</p><p>栈的明显的操作特征为<strong>后进先出</strong>（<em>Last In First Out</em>，<em><strong>LIFO</strong></em>），故又称 后进先出的线性表。</p><h3 id="栈的数学性质">栈的数学性质</h3><p>对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个不同元素按照不同的进栈方式，其出栈次序的可能种数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\frac1{n+1}C_{2n}^{n}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.3908em;vertical-align:-.9454em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4454em"><span style="top:-3.4454em"><span class="pstrut" style="height:3.3214em"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">1</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.7693em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.7144em"><span style="top:-2.453em;margin-left:-.0715em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.247em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9454em"><span></span></span></span></span></span></span></span></span></span></span> .</p><p>下面我们仅给出递推式的推导，对其求解可得到结果正是上面给出的公式，这个公式我们称之为卡特兰数（Catalan）。<br>因为求解过程涉及到柯西乘积，感兴趣请移步到本站关于卡特兰数的相关文章继续深究。</p><p>假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个元素的合法出栈顺序有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 种，自然有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(0)=1,f(1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span>.<br>此外，还假设<strong>进栈次序</strong>依次为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,\cdots,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.1944em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。接下来我们讨论第一个进栈的元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 它有哪些出栈的可能即可。</p><p>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 在出栈序列中，排在第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 个位置，我们可以据此把出栈序列以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 为界限，一分为二：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>a</mi><msub><mi>m</mi><mn>1</mn></msub></msub><mo separator="true">,</mo><msub><mi>a</mi><msub><mi>m</mi><mn>2</mn></msub></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>a</mi><msub><mi>m</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><msub><mi>m</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>a</mi><msub><mi>m</mi><mi>n</mi></msub></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Out=\{(a_{m_1},a_{m_2},\cdots,a_{m_{k-1}}),a_1,(a_{m_{k+1}},\cdots,a_{m_{n}})\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.0475em;vertical-align:-.2975em"></span><span class="mopen">{(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3173em"><span style="top:-2.357em;margin-left:0;margin-right:.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2501em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3173em"><span style="top:-2.357em;margin-left:0;margin-right:.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2501em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3448em"><span style="top:-2.3488em;margin-left:0;margin-right:.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2107em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2975em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3448em"><span style="top:-2.3488em;margin-left:0;margin-right:.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2107em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2975em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1514em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.1645em"><span style="top:-2.357em;margin-left:0;margin-right:.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2501em"><span></span></span></span></span></span></span><span class="mclose">)}</span></span></span></span></span></p><p>对于在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 之前出栈的那<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7778em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span> 个元素来说，因为入栈时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 是第一个入栈的，所以这些元素的出栈次序不依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，是自由进出的一组序列；也就是它们的出栈次序正好就是一个<strong>子问题</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p><p>而对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 之后出栈的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6667em;vertical-align:-.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 个元素，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 出去之后，它们的出栈次序也是自由的，所以也是一个子问题<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span> 。</p><p>根据组合性原理，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 排在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 位置的所有可能的出栈次序个数就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(k-1)f(n-k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)</span></span></span></span>.<br>遍历所有可能的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 的取值，则有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f(n)=\sum_{k=1}^n[f(k-1)f(n-k)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:2.9535em;vertical-align:-1.3021em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em"><span style="top:-1.8479em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mclose">)]</span></span></span></span></span></p><div class="note primary modern"><p>卡特兰数的相关性质与证明见本站文章：<a href="https://qslie.top/posts/41b1e1e3/">算法与组合数学：卡特兰数</a></p></div><h2 id="STL中的栈"><code>STL</code>中的栈</h2><blockquote><p>C++ STL（标准模板库）是一套功能强大的<code>C++</code> 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p></blockquote><p>这里我们通过介绍 <code>STL</code> 中栈的基本操作，也顺便理清了栈的相关操作内容。前者在 ACM 比赛或是 算法机试中较为常用，所以此处一并介绍。</p><hr><h3 id="栈的创建">栈的创建</h3><p>由于 <code>stack</code> 适配器以<strong>模板类</strong> <code>stack&lt;T,Container=deque&lt;T&gt;&gt;</code>（其中 <code>T</code> 为存储元素的类型，<code>Container</code> 表示底层容器的类型）的形式位于 <code>&lt;stack&gt;</code> 头文件中，并定义在 <code>std</code> 命名空间里。<br>因此，在创建该容器之前，程序中应包含以下 2 行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><blockquote><p><code>std</code> 命名空间也可以在使用 <code>stack</code> 适配器时额外注明。</p></blockquote><p>创建一个不包含任何元素的 <code>stack</code> 适配器，并采用默认的 <code>deque</code> 基础容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>&gt; values;</span><br></pre></td></tr></table></figure><h3 id="支持的成员函数">支持的成员函数</h3><p><code>stack</code> 是一类存储机制简单、提供成员函数较少的容器。下表列出了 <code>stack</code> 容器支持的全部成员函数。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td><code>empty()</code></td><td>当 <code>stack</code> 栈中没有元素时，该成员函数返回 <code>true</code>；反之，返回 <code>false</code>。</td></tr><tr><td><code>size()</code></td><td>返回 <code>stack</code> 栈中存储元素的个数。</td></tr><tr><td><code>top()</code></td><td>返回一个栈顶元素的<strong>引用</strong>，类型为 <code>T&amp;</code>。如果栈为空，程序会报错。</td></tr><tr><td><code>push(const T&amp; val)</code></td><td>先复制 <code>val</code>，再将 <code>val</code> 副本压入栈顶。这是通过调用底层容器的 <code>push_back()</code> 函数完成的。</td></tr><tr><td><code>push(T&amp;&amp; obj)</code></td><td>以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 <code>push_back()</code> 函数完成的。</td></tr><tr><td><code>pop()</code></td><td>弹出栈顶元素。</td></tr><tr><td><code>emplace(arg...)</code></td><td><code>arg...</code> 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。</td></tr><tr><td><code>swap(stack&lt;T&gt; &amp; other_stack)</code></td><td>将两个 <code>stack</code> 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 <code>stack</code> 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td></tr></tbody></table><p>使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="comment">//构建 stack 容器适配器</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; values&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">my_stack</span>(values);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查看 my_stack 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_stack: &quot;</span> &lt;&lt; my_stack.<span class="built_in">size</span>() &lt;&lt; endl;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将 my_stack 中存储的元素依次弹栈，直到其为空</span></span><br><span class="line">    <span class="keyword">while</span> (!my_stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; my_stack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">//将栈顶元素弹栈</span></span><br><span class="line">        my_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size of my_stack: 3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="栈的顺序存储">栈的顺序存储</h2><p><strong>顺序栈</strong> 利用一组连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针 <code>top</code> 始终指向当前栈顶元素。（不同教材的定义有所不同）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><blockquote><p>由于顺序栈的入栈操作受数组上界约束，所以对最大空间估计不足时，可能发生<strong>栈上溢</strong>。</p></blockquote><h3 id="基本操作的顺序栈实现">基本操作的顺序栈实现</h3><h4 id="栈顶指针">栈顶指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123; <span class="comment">// 初始化</span></span><br><span class="line">	S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始时，<code>S.top</code> 应置 <code>-1</code>，此时<strong>栈空</strong>；当 <code>S.top == MaxSize-1</code> 时<strong>栈满</strong>。</p><p>栈长：<code>S.top+1</code><br>栈顶元素：通过 <code>S.data[S.top]</code> 访问得到。</p><h4 id="入栈与出栈">入栈与出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 入栈 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判满</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == MaxSize<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//指针上移，并通过top进行赋值</span></span><br><span class="line">	S.data[++S.top] = x; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出栈 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123; <span class="comment">//注意此处需要 &amp;x</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判空</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//把栈顶元素赋给通过引用得来的x，然后指针下移</span></span><br><span class="line">	x = S.data[S.top--]; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="共享顺序栈">共享顺序栈</h3><p><strong>共享栈</strong> 是利用栈底的位置不变性，将两个顺序栈共享同一个一维数组空间的建栈策略。<br>假设两个栈分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_1,S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，二者共享存储区<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0..</mn><mi>M</mi><mi>a</mi><mi>x</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[0..MaxSize-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">0..</span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 。采用栈顶相向，迎面增长的方式进行存储，即栈底设置在两端、栈顶 向共享空间的中间延申。如下图所示：</p><p>我们规定 <code>top1 == -1</code> 表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的栈空；<code>top2 == MaxSize</code> 表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的栈空。<br>当且仅当二者的栈顶指针相邻，<code>top2-top1 == 1</code> 时，栈满。</p><p>（此规定不同教材的定义有所不同）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType stack[MaxSize];</span><br><span class="line">	<span class="type">int</span> top[<span class="number">2</span>]; <span class="comment">//两个栈顶指针</span></span><br><span class="line">&#125;ShareStk;</span><br><span class="line"></span><br><span class="line">ShareStk S; <span class="comment">//建立全局共享栈变量</span></span><br></pre></td></tr></table></figure><p>下面是共享栈的入栈与出栈的实现，通过传递形参标志 <code>index</code> 表名当前需要对左边还是右边的栈进行入栈或出栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 入栈 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> index, ElemType x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//无效标志</span></span><br><span class="line">	<span class="keyword">if</span>(S.top[<span class="number">1</span>] - S.top[<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满</span></span><br><span class="line">	<span class="keyword">switch</span>(index)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			S.stack[++S.top[<span class="number">0</span>]] = x;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			S.stack[--S.top[<span class="number">1</span>]] = x;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出栈 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(<span class="type">int</span> index, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//无效标志</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(index)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span>(S.top[<span class="number">0</span>] == <span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈空</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				x = S.stack[S.top[<span class="number">0</span>]--];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">if</span>(S.top[<span class="number">1</span>] == MaxSize)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈空</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				x = S.stack[S.top[<span class="number">1</span>]++];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的链式存储">栈的链式存储</h2><p><strong>链栈</strong> 的优点是便于多个栈共享存储空间以及提高效率，并且不存在上溢。<br>链栈通常采用单链表实现，并且<strong>规定所有操作都在表头进行</strong>。</p><p>下面是以<strong>不预设头结点为前提</strong>的链栈类型描述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; *LinkStack;</span><br></pre></td></tr></table></figure><h1>队列</h1><h2 id="队列的基本概念">队列的基本概念</h2><p>队列（<em>Queue</em>）简称：队。也是一种操作受限的<strong>线性表</strong>。<br>要求只允许在表的一段进行插入（称为<strong>入队</strong>），而在表的另一端进行删除（称为 <strong>出队</strong>）。</p><p><strong>特点</strong>：<strong>先进先出</strong>（<em>First In First Out</em>，<em><strong>FIFO</strong></em>）。</p><ul><li>空队列：不含任何元素的空表。</li><li>队尾（<em>Rear</em>）：<strong>允许插入的一端</strong>。此时，队列中最靠近队尾的一个元素叫作<strong>队尾元素</strong>。</li><li>队头（<em>Front</em>）：<strong>允许删除的一端</strong>。相应的，最靠近队头的一个元素叫作<strong>队头元素</strong>。</li></ul><h2 id="STL中的队列"><code>STL</code>中的队列</h2><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202211011441684.png" alt="STL中的队列容器"></p><p><code>queue</code> 容器适配器和 <code>stack</code> 的创建和操作都说类似的。并且有一些成员函数相似，但在一些情况下，工作方式有些不同。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td><code>empty()</code></td><td>如果 <code>queue</code> 中没有元素的话，返回 <code>true</code>。</td></tr><tr><td><code>size()</code></td><td>返回 <code>queue</code> 中元素的个数。</td></tr><tr><td><code>front()</code></td><td>返回 <code>queue</code> 中第一个元素的引用。如果 <code>queue</code> 是常量，就返回一个常引用；如果 <code>queue</code> 为空，返回值是未定义的。</td></tr><tr><td><code>back()</code></td><td>返回 <code>queue</code> 中最后一个元素的引用。如果 <code>queue</code> 是常量，就返回一个常引用；如果 <code>queue</code> 为空，返回值是未定义的。</td></tr><tr><td><code>push(const T&amp; obj)</code></td><td>在 <code>queue</code> 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 <code>push_back()</code> 来完成的。</td></tr><tr><td><code>emplace()</code></td><td>在 <code>queue</code> 的尾部直接添加一个元素。</td></tr><tr><td><code>push(T&amp;&amp; obj)</code></td><td>以移动的方式在 <code>queue</code> 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 <code>push_back()</code> 来完成的。</td></tr><tr><td><code>pop()</code></td><td>删除 <code>queue</code> 中的第一个元素。</td></tr><tr><td><code>swap(queue&lt;T&gt; &amp;other_queue)</code></td><td>将两个 <code>queue</code> 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 <code>queue</code> 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td></tr></tbody></table><blockquote><p>和 <code>stack</code> 一样，<code>queue</code> 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。</p></blockquote><p>下面这个例子中演示了表中部分成员函数的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="comment">//构建 queue 容器适配器</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="function">std::queue&lt;<span class="type">int</span>&gt; <span class="title">my_queue</span><span class="params">(values)</span></span>;<span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//查看 my_queue 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_queue: &quot;</span> &lt;&lt; my_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//访问 my_queue 中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!my_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; my_queue.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">//访问过的元素出队列</span></span><br><span class="line">        my_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size of my_queue: 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="队列的顺序存储">队列的顺序存储</h2><p>队列的顺序实现是指分配一块连续的存储空间存放队列元素，并且还需附设两个指针 <code>front, rear</code> 分别指向队头和队尾。<br>我们规定，<code>rear</code> 指向队尾元素的下一个位置；<code>front</code> 指向对头元素。（不同教材的定义有所不同）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h3 id="队指针">队指针</h3><p>根据我们前面提到的规定，有：</p><ul><li>初始状态：<code>Q.front == Q.rear == 0</code></li><li>判空：<code>Q.front == Q.rear</code></li><li>入队操作：队不满时，将值送到队尾所指处，队尾指针加1；</li><li>出队操作：队不空时，取出队头元素，队头指针加1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123; <span class="comment">// 初始化</span></span><br><span class="line">	Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span></span>&#123; <span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们并不能用 <code>Q.rear == MaxSize</code> 来作为<strong>判满</strong>条件。<br>原因是我们对队列的入队出队处理是通过移动指针实现的，出队时，<code>Q.front</code> 会上移，如下图的 (d) 部分所示。此时入队会出现上溢出，但这种溢出是一种”假溢出“。</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202211011459805.jpg" alt="队列的操作"></p><p>在真正介绍入队与出队的编程实现之前，我们也在图中发现了这种”假溢出“的缺陷。为了克服这种缺陷，我们将引入<strong>循环队列</strong>的思想。</p><h3 id="循环队列">循环队列</h3><p>我们知道，当队头和队尾指针在经过复数次出队入队后，它们的位置可能会移动到数组较后的位置，此时前面的空闲空间将得不了使用，也就是前面给出的图示那样，之后还会出现假溢出问题。</p><p>为了解决这个问题，我们将顺序队列臆造为一个<strong>环状的空间</strong>，使得存储队列元素的表从<strong>逻辑上</strong>成为一个环，这样的队列就是循环队列。</p><p>最简单的实现方法就是当队首指针 <code>Q.front == MaxSize-1</code> 之后，若它再前进，就把它调整到 <code>0</code> 的位置。这可以直接用<strong>模运算</strong>实现！</p><ol><li>初始时：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo>=</mo><mi>Q</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">Q.front=Q.rear=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">Q</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord mathnormal">Q</span><span class="mord">.</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span></span></span></span></li><li>队首指针进1：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo>←</mo><mo stretchy="false">(</mo><mi>Q</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.6667em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">Q.front\leftarrow(Q.front+1)\mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">Q</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:.6667em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">n</span></span></span></span></li><li>队首指针进1：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>←</mo><mo stretchy="false">(</mo><mi>Q</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.6667em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">Q.rear\leftarrow(Q.rear+1)\mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord mathnormal">Q</span><span class="mord">.</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord">.</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:.6667em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">n</span></span></span></span></li><li>队列实际长度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>Q</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>−</mo><mi>Q</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.6667em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">(Q.rear-Q.front+n)\mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord">.</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">Q</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:.6667em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">n</span></span></span></span></li></ol><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 是开辟的连续空间的单位个数，即 <code>MaxSize</code></p><hr><p>那么<strong>如何判断队满</strong>呢？</p><p>之前我们规定队空条件是 <code>Q.front==Q.rear</code>。但对于循环队列来说，当元素的入队速度高于出队速度时，就会出现队尾指针在环内追赶上队首指针的情况，此时 <code>Q.front==Q.rear</code> 成立，我们就无法判断当前是队空还是队满了。如下图 (d1) 所示。</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202211011530900.png" alt="循环队列的入队示意图"></p><p>区分队空还是队满，可采用如下三种处理方法。</p><mark class="hl-label green">方法一</mark> 我们 **约定：队头指针指向队尾的下一个位置时队满** ，这样将牺牲一个存储单元，但也是较为普遍的实现方法。如上图 (d2) 所示。<p>于是，队满条件就是 <code>(Q+rear+1)%MaxSize == Q.front</code> ，队空条件不变。</p><mark class="hl-label green">方法二</mark> 增设表示元素个数的数据成员 `size`，从而队空就是 `Q.size == 0`，队满就是 `Q.size == MaxSize` <mark class="hl-label green">方法三</mark> 增设标志 `tag`，因插入导致 `Q.front == Q.rear` 时。`tag` 置 `1`，表示队满，反之因删除导致时，置 `0` 表示队空。<h3 id="入队与出队">入队与出队</h3><p>我们利用普遍使用的<strong>方法一</strong>进行队满判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 入队 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判满</span></span><br><span class="line">	<span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//入队，rear循环上移</span></span><br><span class="line">	Q.data[Q.rear] = x; </span><br><span class="line">	Q.rear = (Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出队 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123; <span class="comment">//注意此处需要 &amp;x</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判空</span></span><br><span class="line">	<span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//把队头元素赋给通过引用得来的x，然后指针循环上移</span></span><br><span class="line">	x = Q.data[Q.front];</span><br><span class="line">	Q.front = (Q.front+<span class="number">1</span>)%MaxSize; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="队列的链式存储">队列的链式存储</h2><p>队列的链式表示称为<strong>链队列</strong>，它实际上是一个同时带有队头指针和队尾指针的单链表。</p><ul><li>头指针指向队头结点；</li><li>尾指针指向队尾结点，也就是单链表的最后一个结点。（注意与顺序队列的不同）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123; <span class="comment">//链表结点类型</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123; <span class="comment">//链队列</span></span><br><span class="line">	LinkNode *front, *rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显然，<br>对于<strong>不带</strong>头结点的链表，当 <code>Q.front == NULL &amp;&amp; Q.rear == NULL</code> 时，队空。<br>对于<strong>带</strong>头结点的链表，当 <code>Q.front == Q.rear</code> 时，队空。</p><p>并且，单链表表示的链队列特别时候数据元素变动比较大的情形，还不会出现队列溢出问题。</p><h3 id="基本操作的链队列实现">基本操作的链队列实现</h3><p>下面描述的都是在<strong>带头结点的单链表</strong>上的实现，因为不带头结点往往需要处理特殊情况，而带上头结点后，插入与删除操作可以得到统一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123; <span class="comment">//初始化</span></span><br><span class="line">	Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">	Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123; <span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123; <span class="comment">//入队</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 与顺序队列不同，此处无需判满</span></span><br><span class="line">	</span><br><span class="line">	LinkNode *s = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">	s-&gt;data = x; s-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 建立新结点s</span></span><br><span class="line">	</span><br><span class="line">	Q.rear-&gt;next = s;</span><br><span class="line">	Q.rear = s; <span class="comment">//结点插入到尾部，尾指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123; <span class="comment">//出队</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//判空</span></span><br><span class="line">	</span><br><span class="line">	LinkNode *p = Q.front-&gt;next; <span class="comment">//p指向队首结点</span></span><br><span class="line">	x = Q.front-&gt;data; <span class="comment">//队首结点的内容传给x</span></span><br><span class="line">	Q.front-&gt;next = p-&gt;next; <span class="comment">//p断链</span></span><br><span class="line">	<span class="keyword">if</span>(Q.rear = p)&#123;</span><br><span class="line">		Q.rear = Q.front;</span><br><span class="line">	&#125; <span class="comment">//若当前只有一个结点，则删除后队为空</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用两个栈模拟队列">利用两个栈模拟队列</h3><div class="note primary modern"><p>现已知两个栈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_1,S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 可供使用，且其入栈、出栈、判空判满操作均以提供。<br>尝试利用两个栈实现模拟一个简单队列的入队出队与判空操作。</p></div><p>简单起见，我们利用 <code>STL</code> 标准库提供的 <code>stack</code> 容器作为“已知各种操作”的两个栈。考虑下面几种情况：</p><ol><li><strong>入队</strong>。入队操作可简单进行，只需保证入队的元素无遗漏地存储在栈中即可，不妨就将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 作为容器，存储入队元素。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 满了，则在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 为空的情况下先全部送入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 再继续存储。</li><li><strong>出队</strong>。由于栈的出栈次序与队列的出队次序正好相反，所以我们把存放于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 中的元素依次弹出（出栈）并放入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 中。此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 的出栈次序就与普通队列一致了，我们只需把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 栈顶元素弹出即可完成出队。但此前需先判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0576em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 是否为空，否则将会产生顺序混乱。</li><li><strong>判空</strong>。</li></ol><blockquote><p>前面我们使用的代码，包括链表与顺序表都是按照 <code>C</code> 语言的写法。<br>这里区别于此，我们采用 <code>C++</code> 面向对象的编写方式给出示例，以展现更加多元的编程。由于 <code>STL</code> 中并没有对栈长做限制，所以这里我们人为进行判满处理。只是作为逻辑上的补充。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue_by2stack</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">		stack&lt;T&gt; s1, s2;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">StackOverflow</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">//栈判满</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Queue_by2stack</span>(T); <span class="comment">//构造函数</span></span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(T)</span></span>; </span><br><span class="line">		<span class="function">T <span class="title">DeQueue</span><span class="params">()</span></span>; <span class="comment">//出队</span></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">//判空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Queue_by2stack&lt;T&gt;::<span class="built_in">Queue_by2stack</span>(T x)&#123;</span><br><span class="line">    s1.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Queue_by2stack&lt;T&gt;::<span class="built_in">StackOverflow</span>(<span class="type">int</span> flag)&#123;</span><br><span class="line">	<span class="keyword">switch</span>(flag)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> s1.<span class="built_in">size</span>() &gt;= MaxSize ?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> s2.<span class="built_in">size</span>() &gt;= MaxSize ?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">default</span>: cout &lt;&lt; <span class="string">&quot;WARNING:无效栈号&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Queue_by2stack&lt;T&gt;::<span class="built_in">EnQueue</span>(T x)&#123; <span class="comment">//入队</span></span><br><span class="line">	T tmp;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">StackOverflow</span>(<span class="number">1</span>))&#123;</span><br><span class="line">		s1.<span class="built_in">push</span>(x); <span class="comment">// S1未满就放S1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">StackOverflow</span>(<span class="number">1</span>) &amp;&amp; !s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ERROR:列满&quot;</span> &lt;&lt; endl; <span class="comment">//S1满但S2有值时，不能放到S2里</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">StackOverflow</span>(<span class="number">1</span>) &amp;&amp; s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			tmp = s1.<span class="built_in">top</span>(); <span class="comment">//弹出首元</span></span><br><span class="line">			s1.<span class="built_in">pop</span>(); <span class="comment">//删除首元</span></span><br><span class="line">			s2.<span class="built_in">push</span>(tmp); <span class="comment">//S1满S2空时，全部搬运到S2</span></span><br><span class="line">		&#125;</span><br><span class="line">		s1.<span class="built_in">push</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Queue_by2stack&lt;T&gt;::<span class="built_in">DeQueue</span>()&#123; <span class="comment">//出队</span></span><br><span class="line">	T tmp;</span><br><span class="line">	<span class="keyword">if</span>(!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		tmp = s2.<span class="built_in">top</span>();</span><br><span class="line">		s2.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">return</span> tmp; <span class="comment">//S2有内容时直接出栈，即为出队</span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ERROR:队列为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			tmp = s1.<span class="built_in">top</span>();</span><br><span class="line">			s1.<span class="built_in">pop</span>();</span><br><span class="line">			s2.<span class="built_in">push</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = s2.<span class="built_in">top</span>();</span><br><span class="line">		s2.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Queue_by2stack&lt;T&gt;::<span class="built_in">isEmpty</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双端队列">双端队列</h2><p>双端队列（<em>Deque</em>）是指允许两端都可以进行入和出队操作的队列。<br><code>deque</code> 是 “<em>double ended queue</em>” 的简称。那就说明元素可以从队头出队和入队，也可以从队尾出队和入队。<br>由此可见，<code>Deque</code> 其实就是 <code>Queue</code> 和 <code>Stack</code> 混合而成的一种<strong>特殊的线性表</strong>，完全可以参考之前面的 <code>Queue, Stack</code> 的实现来构建双端队列的实现。</p><p><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202211021323032.png" alt="双端队列Deque"></p><ul><li>输入受限的双端队列：允许在一段插入和删除，而另一端只允许删除</li><li>输出受限的双端队列：允许在一段插入和删除，而另一端只允许插入</li></ul><p>若限定双端队列从某个端点插入的元素只能从该端点删除，则双端队列就蜕变为了栈底相邻接的栈（注意不是共享栈）。</p><h1>堆栈在算术表达式的应用</h1><h2 id="中缀表达式-sub-Nifix-expression-sub">中缀表达式|<sub>Nifix expression</sub></h2><p>中缀表达式是一个<strong>通用</strong>的算术或逻辑公式表示方法。<br>顾名思义，中缀表达式要求将运算符置于操作数之间，这也是我们最熟悉的算术表达式。<br>如：<code>8*(4-2)/2+5*3</code> 等。</p><p>在计算中缀表达式的值的过程中，由于<strong>算术优先级</strong>等问题计算机需要借助堆栈技术进行处理，具体算法如下：</p><ol><li>建立两个栈分别存放运算符和操作数。（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">NS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">NS</span></span></span></span>: <code>number stack</code> ;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">OS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">OS</span></span></span></span>:<code>operator stack</code> ）</li><li>从左到右依次读取表达式。<ul><li>若读取到运算符，将其与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">OS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">OS</span></span></span></span><strong>栈顶</strong>的运算符<strong>比较优先级</strong>，若栈顶的优先级更高，则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">OS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">OS</span></span></span></span>栈顶的运算符和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">NS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">NS</span></span></span></span>前两个操作数弹出并进行计算，将结果放入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">NS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">NS</span></span></span></span></li><li>若读取到操作数，直接入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">NS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">NS</span></span></span></span></li></ul></li><li>不断压栈执行（重复第2步），直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">OS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">OS</span></span></span></span>空了为止</li><li>取出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">NS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">NS</span></span></span></span>剩下的值（唯一），即为最终结果。</li></ol><blockquote><p>例：<code>8*(4-2)/2+5*3</code></p></blockquote><p><img src="nifix_expression.jpg" alt="中缀示意图"></p><h2 id="前缀表达式-sub-Polish-notation-sub">前缀表达式|<sub>Polish notation</sub></h2><p>前缀表达式是一种<strong>没有括号</strong>的算术表达式，与中缀表达式不同的是，它将运算符写在前面，操作数写在后面。为纪念其发明者波兰数学家Jan Lukasiewicz，前缀表达式也称为“波兰式”(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>o</mi><mi>l</mi><mi>i</mi><mi>s</mi><mi>h</mi><mtext> </mtext><mi>n</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Polish\ notation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>)</p><p><strong>计算表达式的算法</strong>如下：</p><p>[要求<strong>从右往左</strong>读取，优点：<strong>只需要一个栈</strong>]</p><ol><li>依次读取操作数，当读到运算符时，将最近两个操作数进行计算，结果保存到栈之中；</li><li>不断压栈执行（重复第1步），直到<code>stack</code>为止后停止；</li><li>最后的输出值（弹出值），即为最终结果。</li></ol><blockquote><p>继续以前面的例子作为本次计算的基础，但是事先我们需要对表达式继续转化<br>即 将<strong>中缀表达式 转换为 前缀表达式</strong></p><p><code>8 * ( 4 - 2 ) / 2 + 5 * 3</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">→</span></span></span></span> <code>\+ / * 8 - 4 2 2 * 5 3</code></p></blockquote><p><img src="expression_tree.png" alt="表达式的树形结构"></p><h2 id="后缀表达式-逆波兰记法-sub-RPN-Reverse-Polish-notation-sub">后缀表达式/逆波兰记法|<sub>RPN,Reverse Polish notation</sub></h2><p>计算表达式的算法：与前缀表达式的计算法类似，改为<strong>从左至右</strong>即可</p><p>我们先将所需计算的 <strong>中缀表达式转为后缀</strong>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">{</mo><mtext>  </mtext><mn>8</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>4</mn><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mn>5</mn><mo>∗</mo><mn>3</mn><mtext>  </mtext><mo stretchy="false">}</mo><mo>→</mo><mo stretchy="false">{</mo><mtext>  </mtext><mn>8</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mo>−</mo><mtext> </mtext><mn>2</mn><mtext> </mtext><mi mathvariant="normal">/</mi><mtext> </mtext><mo>∗</mo><mtext> </mtext><mn>5</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mo>∗</mo><mtext> </mtext><mo>+</mo><mtext>  </mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\;8 * ( 4 - 2 ) / 2 + 5 * 3\;\} \to \{\;8\ 4\ 2\ -\ 2 \ /\ *\ 5\ 3\ *\ +\;\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord">8</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2778em"></span><span class="mclose">}</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord">8</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">/</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">5</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">+</span><span class="mspace" style="margin-right:.2778em"></span><span class="mclose">}</span></span></span></span></span></p><p><strong>计算</strong>示例：</p><p><img src="RPN_calculate.png" alt="RPN计算"></p><h2 id="变换-sub-Transformation-sub">变换|<sub>Transformation</sub></h2><p>前面我们反复提及将<strong>不同的表示方法相互转化</strong>。其中中缀转前缀和中缀转后缀的算法都十分类似，此处仅给出后者的算法以做示例。<br>算法包括手算和机算两种。</p><h3 id="中缀转后缀-手算">中缀转后缀 |手算</h3><p><strong>中缀转后缀</strong>的手算步骤如下：</p><ol><li><p>确定中缀表达式中<strong>各个运算符的运算顺序</strong>。</p></li><li><p>选择下一个运算符，按照「<strong>左操作数 右操作数 运算符</strong>」的方式组合成一个新的操作数。</p></li><li><p>如果还有运算符没被处理，就继续第 (2) 步。</p></li></ol><p>继续以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>4</mn><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mn>5</mn><mo>∗</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">8*(4-2)/2+5*3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">8</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">3</span></span></span></span> 为例：</p><p>第一步，先处理括号内的内容，把 <code>(4 - 2)</code> 调整为 <code>4 2 -</code> ；<br>第二步，处理除号，把 <code>(4 2 -)</code> 这个整体与 <code>/</code>后面的 <code>2</code> 作为操作数，调整得 <code>4 2 - 2 /</code>；<br>第三步，把 <code>8</code> 与第二步得到的 <code>(4 2 - 2 /)</code> 看作操作数，调整得 <code>8 4 2 - 2 / *</code>；<br>第四步，处理加号后面的 <code>5 * 3</code> ，方法一样（也可以从加号处拆开，两边同时处理）。</p><p>最终得到如下结果：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>N</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>x</mi><mo>=</mo><mn>8</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>4</mn><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mn>5</mn><mo>∗</mo><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⇒</mo><mn>8</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>∗</mo><mo stretchy="false">{</mo><mn>4</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mo>−</mo><mo stretchy="false">}</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>+</mo><mo stretchy="false">{</mo><mn>5</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mo>∗</mo><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⇒</mo><mn>8</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>∗</mo><mo stretchy="false">{</mo><mn>4</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mo>−</mo><mtext> </mtext><mn>2</mn><mtext> </mtext><mi mathvariant="normal">/</mi><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>+</mo><mo stretchy="false">{</mo><mn>5</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mo>∗</mo><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>⇒</mo><mo stretchy="false">{</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mn>8</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mo>−</mo><mtext> </mtext><mn>2</mn><mtext> </mtext><mi mathvariant="normal">/</mi><mtext> </mtext><mo>∗</mo><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>+</mo><mo stretchy="false">{</mo><mn>5</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mo>∗</mo><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>R</mi><mi>P</mi><mi>H</mi><mo>=</mo><mn>8</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mn>2</mn><mtext> </mtext><mo>−</mo><mtext> </mtext><mn>2</mn><mtext> </mtext><mi mathvariant="normal">/</mi><mtext> </mtext><mo>∗</mo><mtext> </mtext><mn>5</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mo>∗</mo><mtext> </mtext><mo>+</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} Nifix=8 * ( 4 - 2 ) / 2 + 5 * 3\\\\ \Rightarrow 8 &amp;* \{ 4\ 2\ -\} / 2 &amp;+ \{5\ 3\ *\}\\ \Rightarrow 8 &amp;* \{ 4\ 2\ - \ 2\ /\} &amp;+ \{5\ 3\ *\}\\ \Rightarrow \{&amp;8\ 4 \ 2\ -\ 2\ /\ *\}&amp;+ \{5\ 3\ *\}\\\\ RPH=8\ 4\ 2\ -\ 2 \ /\ *\ 5\ 3\ *\ + \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:10.5em;vertical-align:-5em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.5em"><span style="top:-7.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord">8</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">3</span></span></span><span style="top:-6.16em"><span class="pstrut" style="height:3em"></span><span class="mord"></span></span><span style="top:-4.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mrel">⇒</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord">8</span></span></span><span style="top:-3.16em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mrel">⇒</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord">8</span></span></span><span style="top:-1.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mrel">⇒</span><span class="mspace" style="margin-right:.2778em"></span><span class="mopen">{</span></span></span><span style="top:-.16em"><span class="pstrut" style="height:3em"></span><span class="mord"></span></span><span style="top:1.34em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">RP</span><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord">8</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">/</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">5</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em"><span style="top:-4.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span><span class="mopen">{</span><span class="mord">4</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mord">−</span><span class="mclose">}</span><span class="mord">/2</span></span></span><span style="top:-3.16em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span><span class="mopen">{</span><span class="mord">4</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">/</span><span class="mclose">}</span></span></span><span style="top:-1.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mord">8</span><span class="mspace"> </span><span class="mord">4</span><span class="mspace"> </span><span class="mord">2</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace"> </span><span class="mspace" style="margin-right:.2222em"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">/</span><span class="mspace"> </span><span class="mord">∗</span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em"><span style="top:-4.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">+</span><span class="mopen">{</span><span class="mord">5</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">∗</span><span class="mclose">}</span></span></span><span style="top:-3.16em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">+</span><span class="mopen">{</span><span class="mord">5</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">∗</span><span class="mclose">}</span></span></span><span style="top:-1.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">+</span><span class="mopen">{</span><span class="mord">5</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">∗</span><span class="mclose">}</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em"><span></span></span></span></span></span></span></span></span></span></span></span></p><h3 id="中缀转后缀-机算">中缀转后缀 |机算</h3><p><strong>创立</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">2</span></span></span></span> 个栈：一个作为<strong>临时存储运算符</strong>的栈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span>（含一个结束符号）；一个作为<strong>存放结果</strong>（逆波兰式）的栈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">2</span></span></span></span>（空栈）.<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span> 栈可先放入优先级最低的运算符<code>#</code>(可指定其他字符，不一定非<code>#</code>不可)</p><p>从中缀式的<strong>左端开始</strong>取字符，逐序进行如下步骤：</p><ol><li><p>若取出的字符是<strong>操作数</strong>则直接送入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">2</span></span></span></span>栈；</p></li><li><p>若取出的字符是<strong>运算符</strong>，则：</p><ul><li>如果该运算符（不包括括号运算符）的<strong>优先级高</strong>于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span> 栈顶运算符（包括左括号）优先级，则将该运算符进<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span> 栈；<br>否则，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span> 栈的栈顶运算符弹出，送入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">2</span></span></span></span>栈中，<strong>直至</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span> 栈栈顶运算符（包括左括号）低于该运算符优先级时<strong>停止</strong>弹出运算符，再将该运算符送入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span> 栈；</li><li>若取出的字符是<code>(</code>，则直接送入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span> 栈顶；</li><li>若取出的字符是<code>)</code>，则将距离<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span> 栈栈顶最近的<code>(</code>之间的所有运算符，逐个出栈，依次送入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">2</span></span></span></span> 栈，此处抛弃<code>(</code>；</li><li>若取出的字符是<code>#</code>，则将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">1</span></span></span></span>栈内所有运算符（不包括<code>#</code>），逐个出栈，依次送入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">2</span></span></span></span>栈。</li></ul></li><li><p>重复上述步骤，直至处理完所有的输入字符；</p></li></ol><p>最终<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">2</span></span></span></span> 栈的内容便为逆波兰式输出结果（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">S2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord">2</span></span></span></span> 的输出需做逆序处理）</p><hr><p>事实上，根据前面的描述，也可以通过构建<strong>二叉树</strong>并对二叉树进行先序遍历、后序遍历的方式实现，此为利用二叉树的算法。</p><p>关于二叉树的各类遍历将在我们后续介绍二叉树时重点阐述。</p><hr><h2 id="代码实现-sub-C-sub">代码实现|<sub>C++</sub></h2><blockquote><p>待更</p></blockquote><h1>参考</h1><ol><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/391237550">怎么理解出栈顺序有多少种？|知乎</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SamWeb/p/15944747.html">双端队列的实现（有图）|博客园</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Healist/article/details/54632395">算术表达式求解——堆栈的应用|Healist</a></li><li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F">逆波兰式|百度百科</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44421143/article/details/124235519">数据结构.3 栈与队列 |CSDN</a></li></ol></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>堆栈与队列及其应用|数据结构Ⅱ</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://qslie.top/posts/f48d0f84/">https://qslie.top/posts/f48d0f84/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Slie</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-12-08</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-03-11</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80/">语言</a></div><div class="post_share"><div class="social-share" data-image="https://z3.ax1x.com/2021/04/17/c5P76I.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">打赏</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png"></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png"></a><div class="post-qr-code-desc"></div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.16/audio/coin.mp3"></audio><script defer src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20ec17ac/" title="树与二叉树与森林|数据结构Ⅲ"><img class="cover" src="/posts/20ec17ac/Fractal_Tree.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">树与二叉树与森林|数据结构Ⅲ</div></div></a></div><div class="next-post pull-right"><a href="/posts/b839b0b/" title="以愚民之身|2021.12"><img class="cover" src="/posts/b839b0b/momoramen.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">以愚民之身|2021.12</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/04/09/Likong.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Slie</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sliefamily"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://qm.qq.com/cgi-bin/qm/qr?k=1hPHFQqPhpkbBVYbFjRC4q8YQ-A72EFL&amp;noverify=0" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/SlieFamily" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sliewdyinwhite@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">秘密基地被发现啦！QAQ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">栈的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%95%B0%E5%AD%A6%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">栈的数学性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E4%B8%AD%E7%9A%84%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">STL中的栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">栈的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">支持的成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.</span> <span class="toc-text">栈的顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本操作的顺序栈实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E6%8C%87%E9%92%88"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">栈顶指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E6%A0%88%E4%B8%8E%E5%87%BA%E6%A0%88"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">入栈与出栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">共享顺序栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.</span> <span class="toc-text">栈的链式存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">队列的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">STL中的队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.3.</span> <span class="toc-text">队列的顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E6%8C%87%E9%92%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">队指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.3.2.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%98%9F%E4%B8%8E%E5%87%BA%E9%98%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">入队与出队</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.4.</span> <span class="toc-text">队列的链式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E9%93%BE%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">基本操作的链队列实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="toc-number">2.4.2.</span> <span class="toc-text">利用两个栈模拟队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.5.</span> <span class="toc-text">双端队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">堆栈在算术表达式的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-sub-Nifix-expression-sub"><span class="toc-number">3.1.</span> <span class="toc-text">中缀表达式|Nifix expression</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-sub-Polish-notation-sub"><span class="toc-number">3.2.</span> <span class="toc-text">前缀表达式|Polish notation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%B0%E6%B3%95-sub-RPN-Reverse-Polish-notation-sub"><span class="toc-number">3.3.</span> <span class="toc-text">后缀表达式&#x2F;逆波兰记法|RPN,Reverse Polish notation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2-sub-Transformation-sub"><span class="toc-number">3.4.</span> <span class="toc-text">变换|Transformation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80-%E6%89%8B%E7%AE%97"><span class="toc-number">3.4.1.</span> <span class="toc-text">中缀转后缀 |手算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80-%E6%9C%BA%E7%AE%97"><span class="toc-number">3.4.2.</span> <span class="toc-text">中缀转后缀 |机算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-sub-C-sub"><span class="toc-number">3.5.</span> <span class="toc-text">代码实现|C++</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d3d469f8/" title="Docker - 一步到位的应用部署与上线"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/docker.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Docker - 一步到位的应用部署与上线"></a><div class="content"><a class="title" href="/posts/d3d469f8/" title="Docker - 一步到位的应用部署与上线">Docker - 一步到位的应用部署与上线</a><time datetime="2024-03-05T07:11:45.000Z" title="发表于 2024-03-05 15:11:45">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1bb1ae1/" title="GFS - 谷歌的分布式文件存储系统"><img src="http://img.49you.com/20170303/58b8d6f32d651.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="GFS - 谷歌的分布式文件存储系统"></a><div class="content"><a class="title" href="/posts/c1bb1ae1/" title="GFS - 谷歌的分布式文件存储系统">GFS - 谷歌的分布式文件存储系统</a><time datetime="2024-03-05T04:04:07.000Z" title="发表于 2024-03-05 12:04:07">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f21b6bc8/" title="HuskyLab Servers 0x519 操作指南【自用】"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/husklab_bg.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="HuskyLab Servers 0x519 操作指南【自用】"></a><div class="content"><a class="title" href="/posts/f21b6bc8/" title="HuskyLab Servers 0x519 操作指南【自用】">HuskyLab Servers 0x519 操作指南【自用】</a><time datetime="2024-03-04T13:29:31.000Z" title="发表于 2024-03-04 21:29:31">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7dae821/" title="【快速入门】集群资源管理调度系统 - Slurm"><img src="https://gitee.com/sliewdy/ImageURL-slie/raw/master/imagesNoT/QQ%E5%9B%BE%E7%89%8720210414005713.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【快速入门】集群资源管理调度系统 - Slurm"></a><div class="content"><a class="title" href="/posts/f7dae821/" title="【快速入门】集群资源管理调度系统 - Slurm">【快速入门】集群资源管理调度系统 - Slurm</a><time datetime="2024-03-04T12:50:38.000Z" title="发表于 2024-03-04 20:50:38">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8cb817a9/" title="【最优化】Levenberg-Marquardt 算法"><img src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/202401051550627.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="【最优化】Levenberg-Marquardt 算法"></a><div class="content"><a class="title" href="/posts/8cb817a9/" title="【最优化】Levenberg-Marquardt 算法">【最优化】Levenberg-Marquardt 算法</a><time datetime="2023-12-22T03:07:39.000Z" title="发表于 2023-12-22 11:07:39">2023-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('https://z3.ax1x.com/2021/04/17/c5P76I.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Slie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to Chaos World!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("/pluginsSrc/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" href="/pluginsSrc/katex/dist/katex.min.css"><script src="/pluginsSrc/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{btf.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("/pluginsSrc/mermaid/dist/mermaid.min.js").then(t)};btf.addModeChange("mermaid",t),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.qslie.top/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.qslie.top/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.textContent=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script async src="/js/diytitle.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script async src="/js/diytitle.js"></script><script data-pjax defer src="/js/fixed_comment.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/pluginsSrc/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 算法相关，编程实现 (60)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/故事/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 杂谈日志，光影记录 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/日常/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 记忆碎片，梦境显影 (36)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://qslie.top/tags/机器学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💻 机器学习，数学规划 (35)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://qslie.top/tags" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4f5fd499/" alt=""><img width="48" height="48" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main//Auto/20231030204417.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/4f5fd499/" alt="">Deep Neural Net | 多层感知机与神经网络入门</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="posts/4f5fd499/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/9a95977b/" alt=""><img width="48" height="48" src="math-cover.jfif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/9a95977b/" alt="">SLie的&quot;数学基础&quot;集装箱|Perhaps.Ver1.04</a><div class="blog-slider__text">好了，你已经学会1+1=2了，下面来证明一下广义黎曼猜想吧~</div><a class="blog-slider__button" href="posts/9a95977b/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4ea9ab3c/" alt=""><img width="48" height="48" src="https://jsd.onmicrosoft.cn/gh/SlieFamily/TempImages@main/Auto/202202232045587.jpeg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/4ea9ab3c/" alt="">算法分析与设计 &amp; 本站算法综述</a><div class="blog-slider__text">本文罗列了常见的经典问题和算法，以及主要的算法分析方法和设计方法</div><a class="blog-slider__button" href="posts/4ea9ab3c/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/5ebaa4d9/" alt=""><img width="48" height="48" src="https://gitee.com/sliewdy/ImageURL-slie/raw/master/imagesNoT/QQ%E5%9B%BE%E7%89%8720210414005713.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-11</span><a class="blog-slider__title" href="posts/5ebaa4d9/" alt="">捣鼓程序时的各种【踩坑】【报错】全收录</a><div class="blog-slider__text">配置环境、安装库包等网上冲浪时遇见到的各式各样奇奇怪怪的Warning和Error，以及各种治标不治本或者又治标又治本的解决方案全记录（个人向）</div><a class="blog-slider__button" href="posts/5ebaa4d9/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>